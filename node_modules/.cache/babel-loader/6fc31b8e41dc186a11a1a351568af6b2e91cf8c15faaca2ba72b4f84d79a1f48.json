{"ast":null,"code":"/**\n * Transaction storage service for managing user trade history\n */\n\n/**\n * Transaction Storage Service\n */\nexport class TransactionStorageService {\n  constructor() {\n    this.STORAGE_KEY_PREFIX = 'cryptosniper_transactions_';\n    this.STORAGE_META_KEY = 'cryptosniper_tx_meta_';\n    this.MAX_TRANSACTIONS_PER_PAGE = 25;\n    this.MIN_DASHBOARD_DISPLAY = 10;\n    this.MAX_RAM_TRANSACTIONS = 100;\n  }\n  // Keep max 100 in memory\n\n  /**\n   * Save transaction to user's history\n   */\n  saveTransaction(userId, transaction) {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const currentPage = Math.floor(meta.totalTransactions / this.MAX_TRANSACTIONS_PER_PAGE);\n\n      // Get current page transactions\n      const pageTransactions = this.getTransactionPage(userId, currentPage);\n\n      // Add new transaction at the beginning\n      pageTransactions.unshift(transaction);\n\n      // If page is full, move oldest to next page\n      if (pageTransactions.length > this.MAX_TRANSACTIONS_PER_PAGE) {\n        const overflow = pageTransactions.splice(this.MAX_TRANSACTIONS_PER_PAGE);\n        this.saveTransactionPage(userId, currentPage + 1, overflow);\n      }\n\n      // Save current page\n      this.saveTransactionPage(userId, currentPage, pageTransactions);\n\n      // Update metadata\n      meta.totalTransactions++;\n      meta.totalPages = Math.ceil(meta.totalTransactions / this.MAX_TRANSACTIONS_PER_PAGE);\n      meta.lastUpdated = Date.now();\n      this.saveTransactionMeta(userId, meta);\n      console.log(`ðŸ’¾ Transaction saved for user ${userId}`);\n    } catch (error) {\n      console.error('Error saving transaction:', error);\n    }\n  }\n\n  /**\n   * Get transactions for dashboard display (most recent, limited)\n   */\n  getDashboardTransactions(userId) {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      if (meta.totalTransactions === 0) return [];\n\n      // Get first page (most recent)\n      const firstPage = this.getTransactionPage(userId, 0);\n\n      // Return minimum display amount or less\n      return firstPage.slice(0, this.MIN_DASHBOARD_DISPLAY);\n    } catch (error) {\n      console.error('Error loading dashboard transactions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get paginated transaction history\n   */\n  getTransactionHistory(userId, page = 0) {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const transactions = this.getTransactionPage(userId, page);\n      return {\n        transactions,\n        page,\n        totalPages: meta.totalPages,\n        totalTransactions: meta.totalTransactions\n      };\n    } catch (error) {\n      console.error('Error loading transaction history:', error);\n      return {\n        transactions: [],\n        page: 0,\n        totalPages: 0,\n        totalTransactions: 0\n      };\n    }\n  }\n\n  /**\n   * Get user transaction statistics\n   */\n  getTransactionStats(userId) {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const recentTransactions = this.getDashboardTransactions(userId);\n      const successful = recentTransactions.filter(tx => tx.status === 'success').length;\n      const failed = recentTransactions.filter(tx => tx.status === 'failed').length;\n      const pending = recentTransactions.filter(tx => tx.status === 'pending').length;\n      const totalProfit = recentTransactions.filter(tx => tx.profit !== undefined).reduce((sum, tx) => sum + (tx.profit || 0), 0);\n      const completedTransactions = successful + failed;\n      const successRate = completedTransactions > 0 ? successful / completedTransactions * 100 : 0;\n      return {\n        total: meta.totalTransactions,\n        successful,\n        failed,\n        pending,\n        totalProfit,\n        successRate\n      };\n    } catch (error) {\n      console.error('Error calculating transaction stats:', error);\n      return {\n        total: 0,\n        successful: 0,\n        failed: 0,\n        pending: 0,\n        totalProfit: 0,\n        successRate: 0\n      };\n    }\n  }\n\n  /**\n   * Clear old transactions to manage memory\n   */\n  cleanupOldTransactions(userId) {\n    try {\n      const meta = this.getTransactionMeta(userId);\n\n      // If total transactions exceed RAM limit, remove oldest pages\n      if (meta.totalTransactions > this.MAX_RAM_TRANSACTIONS) {\n        const pagesToKeep = Math.ceil(this.MAX_RAM_TRANSACTIONS / this.MAX_TRANSACTIONS_PER_PAGE);\n        const pagesToDelete = meta.totalPages - pagesToKeep;\n\n        // Remove oldest pages\n        for (let page = meta.totalPages - 1; page >= pagesToKeep; page--) {\n          localStorage.removeItem(`${this.STORAGE_KEY_PREFIX}${userId}_page_${page}`);\n        }\n\n        // Update metadata\n        meta.totalPages = pagesToKeep;\n        meta.totalTransactions = this.MAX_RAM_TRANSACTIONS;\n        this.saveTransactionMeta(userId, meta);\n        console.log(`ðŸ§¹ Cleaned up ${pagesToDelete} transaction pages for user ${userId}`);\n      }\n    } catch (error) {\n      console.error('Error cleaning up transactions:', error);\n    }\n  }\n\n  /**\n   * Export transaction history for user\n   */\n  exportTransactionHistory(userId) {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const allTransactions = [];\n\n      // Collect all transactions from all pages\n      for (let page = 0; page < meta.totalPages; page++) {\n        const pageTransactions = this.getTransactionPage(userId, page);\n        allTransactions.push(...pageTransactions);\n      }\n      return JSON.stringify({\n        userId,\n        exportDate: new Date().toISOString(),\n        totalTransactions: allTransactions.length,\n        transactions: allTransactions\n      }, null, 2);\n    } catch (error) {\n      console.error('Error exporting transaction history:', error);\n      return '{}';\n    }\n  }\n\n  // Private helper methods\n  getStorageKey(userId, page) {\n    return `${this.STORAGE_KEY_PREFIX}${userId}_page_${page}`;\n  }\n  getMetaKey(userId) {\n    return `${this.STORAGE_META_KEY}${userId}`;\n  }\n  getTransactionPage(userId, page) {\n    try {\n      const key = this.getStorageKey(userId, page);\n      const data = localStorage.getItem(key);\n      return data ? JSON.parse(data) : [];\n    } catch (error) {\n      return [];\n    }\n  }\n  saveTransactionPage(userId, page, transactions) {\n    const key = this.getStorageKey(userId, page);\n    localStorage.setItem(key, JSON.stringify(transactions));\n  }\n  getTransactionMeta(userId) {\n    try {\n      const key = this.getMetaKey(userId);\n      const data = localStorage.getItem(key);\n      return data ? JSON.parse(data) : {\n        totalTransactions: 0,\n        totalPages: 0,\n        lastUpdated: Date.now()\n      };\n    } catch (error) {\n      return {\n        totalTransactions: 0,\n        totalPages: 0,\n        lastUpdated: Date.now()\n      };\n    }\n  }\n  saveTransactionMeta(userId, meta) {\n    const key = this.getMetaKey(userId);\n    localStorage.setItem(key, JSON.stringify(meta));\n  }\n}\n\n/**\n * Singleton instance\n */\nexport const transactionStorage = new TransactionStorageService();","map":{"version":3,"names":["TransactionStorageService","constructor","STORAGE_KEY_PREFIX","STORAGE_META_KEY","MAX_TRANSACTIONS_PER_PAGE","MIN_DASHBOARD_DISPLAY","MAX_RAM_TRANSACTIONS","saveTransaction","userId","transaction","meta","getTransactionMeta","currentPage","Math","floor","totalTransactions","pageTransactions","getTransactionPage","unshift","length","overflow","splice","saveTransactionPage","totalPages","ceil","lastUpdated","Date","now","saveTransactionMeta","console","log","error","getDashboardTransactions","firstPage","slice","getTransactionHistory","page","transactions","getTransactionStats","recentTransactions","successful","filter","tx","status","failed","pending","totalProfit","profit","undefined","reduce","sum","completedTransactions","successRate","total","cleanupOldTransactions","pagesToKeep","pagesToDelete","localStorage","removeItem","exportTransactionHistory","allTransactions","push","JSON","stringify","exportDate","toISOString","getStorageKey","getMetaKey","key","data","getItem","parse","setItem","transactionStorage"],"sources":["C:/Users/tpars/source/repos/Crypto Sniper Pro_ AI-Powered Ethereum Trading App/src/services/transactionStorage.ts"],"sourcesContent":["/**\n * Transaction storage service for managing user trade history\n */\n\nimport { Transaction } from '../types/trading';\n\ninterface TransactionPage {\n  transactions: Transaction[];\n  page: number;\n  totalPages: number;\n  totalTransactions: number;\n}\n\n/**\n * Transaction Storage Service\n */\nexport class TransactionStorageService {\n  private readonly STORAGE_KEY_PREFIX = 'cryptosniper_transactions_';\n  private readonly STORAGE_META_KEY = 'cryptosniper_tx_meta_';\n  private readonly MAX_TRANSACTIONS_PER_PAGE = 25;\n  private readonly MIN_DASHBOARD_DISPLAY = 10;\n  private readonly MAX_RAM_TRANSACTIONS = 100; // Keep max 100 in memory\n\n  /**\n   * Save transaction to user's history\n   */\n  saveTransaction(userId: string, transaction: Transaction): void {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const currentPage = Math.floor(meta.totalTransactions / this.MAX_TRANSACTIONS_PER_PAGE);\n      \n      // Get current page transactions\n      const pageTransactions = this.getTransactionPage(userId, currentPage);\n      \n      // Add new transaction at the beginning\n      pageTransactions.unshift(transaction);\n      \n      // If page is full, move oldest to next page\n      if (pageTransactions.length > this.MAX_TRANSACTIONS_PER_PAGE) {\n        const overflow = pageTransactions.splice(this.MAX_TRANSACTIONS_PER_PAGE);\n        this.saveTransactionPage(userId, currentPage + 1, overflow);\n      }\n      \n      // Save current page\n      this.saveTransactionPage(userId, currentPage, pageTransactions);\n      \n      // Update metadata\n      meta.totalTransactions++;\n      meta.totalPages = Math.ceil(meta.totalTransactions / this.MAX_TRANSACTIONS_PER_PAGE);\n      meta.lastUpdated = Date.now();\n      \n      this.saveTransactionMeta(userId, meta);\n      \n      console.log(`ðŸ’¾ Transaction saved for user ${userId}`);\n    } catch (error) {\n      console.error('Error saving transaction:', error);\n    }\n  }\n\n  /**\n   * Get transactions for dashboard display (most recent, limited)\n   */\n  getDashboardTransactions(userId: string): Transaction[] {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      if (meta.totalTransactions === 0) return [];\n      \n      // Get first page (most recent)\n      const firstPage = this.getTransactionPage(userId, 0);\n      \n      // Return minimum display amount or less\n      return firstPage.slice(0, this.MIN_DASHBOARD_DISPLAY);\n    } catch (error) {\n      console.error('Error loading dashboard transactions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get paginated transaction history\n   */\n  getTransactionHistory(userId: string, page: number = 0): TransactionPage {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const transactions = this.getTransactionPage(userId, page);\n      \n      return {\n        transactions,\n        page,\n        totalPages: meta.totalPages,\n        totalTransactions: meta.totalTransactions\n      };\n    } catch (error) {\n      console.error('Error loading transaction history:', error);\n      return {\n        transactions: [],\n        page: 0,\n        totalPages: 0,\n        totalTransactions: 0\n      };\n    }\n  }\n\n  /**\n   * Get user transaction statistics\n   */\n  getTransactionStats(userId: string): {\n    total: number;\n    successful: number;\n    failed: number;\n    pending: number;\n    totalProfit: number;\n    successRate: number;\n  } {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const recentTransactions = this.getDashboardTransactions(userId);\n      \n      const successful = recentTransactions.filter(tx => tx.status === 'success').length;\n      const failed = recentTransactions.filter(tx => tx.status === 'failed').length;\n      const pending = recentTransactions.filter(tx => tx.status === 'pending').length;\n      \n      const totalProfit = recentTransactions\n        .filter(tx => tx.profit !== undefined)\n        .reduce((sum, tx) => sum + (tx.profit || 0), 0);\n      \n      const completedTransactions = successful + failed;\n      const successRate = completedTransactions > 0 ? (successful / completedTransactions) * 100 : 0;\n      \n      return {\n        total: meta.totalTransactions,\n        successful,\n        failed,\n        pending,\n        totalProfit,\n        successRate\n      };\n    } catch (error) {\n      console.error('Error calculating transaction stats:', error);\n      return {\n        total: 0,\n        successful: 0,\n        failed: 0,\n        pending: 0,\n        totalProfit: 0,\n        successRate: 0\n      };\n    }\n  }\n\n  /**\n   * Clear old transactions to manage memory\n   */\n  cleanupOldTransactions(userId: string): void {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      \n      // If total transactions exceed RAM limit, remove oldest pages\n      if (meta.totalTransactions > this.MAX_RAM_TRANSACTIONS) {\n        const pagesToKeep = Math.ceil(this.MAX_RAM_TRANSACTIONS / this.MAX_TRANSACTIONS_PER_PAGE);\n        const pagesToDelete = meta.totalPages - pagesToKeep;\n        \n        // Remove oldest pages\n        for (let page = meta.totalPages - 1; page >= pagesToKeep; page--) {\n          localStorage.removeItem(`${this.STORAGE_KEY_PREFIX}${userId}_page_${page}`);\n        }\n        \n        // Update metadata\n        meta.totalPages = pagesToKeep;\n        meta.totalTransactions = this.MAX_RAM_TRANSACTIONS;\n        this.saveTransactionMeta(userId, meta);\n        \n        console.log(`ðŸ§¹ Cleaned up ${pagesToDelete} transaction pages for user ${userId}`);\n      }\n    } catch (error) {\n      console.error('Error cleaning up transactions:', error);\n    }\n  }\n\n  /**\n   * Export transaction history for user\n   */\n  exportTransactionHistory(userId: string): string {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const allTransactions: Transaction[] = [];\n      \n      // Collect all transactions from all pages\n      for (let page = 0; page < meta.totalPages; page++) {\n        const pageTransactions = this.getTransactionPage(userId, page);\n        allTransactions.push(...pageTransactions);\n      }\n      \n      return JSON.stringify({\n        userId,\n        exportDate: new Date().toISOString(),\n        totalTransactions: allTransactions.length,\n        transactions: allTransactions\n      }, null, 2);\n    } catch (error) {\n      console.error('Error exporting transaction history:', error);\n      return '{}';\n    }\n  }\n\n  // Private helper methods\n  private getStorageKey(userId: string, page: number): string {\n    return `${this.STORAGE_KEY_PREFIX}${userId}_page_${page}`;\n  }\n\n  private getMetaKey(userId: string): string {\n    return `${this.STORAGE_META_KEY}${userId}`;\n  }\n\n  private getTransactionPage(userId: string, page: number): Transaction[] {\n    try {\n      const key = this.getStorageKey(userId, page);\n      const data = localStorage.getItem(key);\n      return data ? JSON.parse(data) : [];\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private saveTransactionPage(userId: string, page: number, transactions: Transaction[]): void {\n    const key = this.getStorageKey(userId, page);\n    localStorage.setItem(key, JSON.stringify(transactions));\n  }\n\n  private getTransactionMeta(userId: string): {\n    totalTransactions: number;\n    totalPages: number;\n    lastUpdated: number;\n  } {\n    try {\n      const key = this.getMetaKey(userId);\n      const data = localStorage.getItem(key);\n      return data ? JSON.parse(data) : {\n        totalTransactions: 0,\n        totalPages: 0,\n        lastUpdated: Date.now()\n      };\n    } catch (error) {\n      return {\n        totalTransactions: 0,\n        totalPages: 0,\n        lastUpdated: Date.now()\n      };\n    }\n  }\n\n  private saveTransactionMeta(userId: string, meta: {\n    totalTransactions: number;\n    totalPages: number;\n    lastUpdated: number;\n  }): void {\n    const key = this.getMetaKey(userId);\n    localStorage.setItem(key, JSON.stringify(meta));\n  }\n}\n\n/**\n * Singleton instance\n */\nexport const transactionStorage = new TransactionStorageService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}