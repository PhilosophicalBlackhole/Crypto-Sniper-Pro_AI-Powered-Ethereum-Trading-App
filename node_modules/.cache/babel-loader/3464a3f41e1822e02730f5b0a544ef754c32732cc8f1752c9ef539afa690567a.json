{"ast":null,"code":"/**\n * Advanced trading hook with gas estimation, smart slippage, and batch processing\n */import{useState,useEffect,useCallback,useRef}from'react';export function useAdvancedTrading(){const[gasEstimations,setGasEstimations]=useState(new Map());const[transactionQueue,setTransactionQueue]=useState([]);const[slippageCalculations,setSlippageCalculations]=useState(new Map());const[networkStats,setNetworkStats]=useState({baseFee:15,fastGasPrice:25,networkCongestion:'medium',avgBlockTime:12});const nonceRef=useRef(0);const processingQueue=useRef(false);/**\n   * Dynamic gas fee estimation with EIP-1559 support\n   */const estimateGas=useCallback(async(tokenAddress,amount)=>{try{// Simulate gas estimation (in production, this would call actual RPC)\nconst baseFee=networkStats.baseFee;const priorityFee=Math.max(2,baseFee*0.1);const maxFeePerGas=baseFee*2+priorityFee;const gasLimit=150000+Math.floor(Math.random()*50000);const estimation={baseFee,maxFeePerGas,maxPriorityFeePerGas:priorityFee,gasLimit,estimatedCost:maxFeePerGas*gasLimit/1e18,executionTime:networkStats.avgBlockTime+(networkStats.networkCongestion==='high'?20:networkStats.networkCongestion==='medium'?10:5),confidence:Math.random()*0.3+0.7// 70-100% confidence\n};setGasEstimations(prev=>new Map(prev.set(tokenAddress,estimation)));return estimation;}catch(error){console.error('Gas estimation failed:',error);throw error;}},[networkStats]);/**\n   * Smart slippage adjustment based on liquidity and volatility\n   */const calculateSmartSlippage=useCallback((tokenAddress,baseSlippage,maxSlippage,liquidityThreshold,volatilityMultiplier)=>{// Simulate market conditions\nconst liquidity=Math.random()*5000000+100000;// $100K - $5M\nconst volatility=Math.random()*50+5;// 5% - 55%\nconst volume24h=Math.random()*1000000+10000;// $10K - $1M\n// Calculate adjustment factors\nconst liquidityFactor=Math.max(0.5,Math.min(2,liquidityThreshold/liquidity));const volatilityFactor=Math.max(0.5,Math.min(3,volatility/20));const volumeFactor=Math.max(0.8,Math.min(1.5,volume24h/500000));// Calculate adjusted slippage\nconst adjustedSlippage=baseSlippage*liquidityFactor*volatilityFactor*volumeFactor*volatilityMultiplier;const recommendedSlippage=Math.min(maxSlippage,Math.max(baseSlippage*0.5,adjustedSlippage));const calculation={baseSlippage,adjustedSlippage,liquidityFactor,volatilityFactor,recommendedSlippage,confidence:Math.random()*0.4+0.6// 60-100% confidence\n};setSlippageCalculations(prev=>new Map(prev.set(tokenAddress,calculation)));return calculation;},[]);/**\n   * Advanced stop-loss and take-profit logic\n   */const calculateExitStrategy=useCallback((buyPrice,currentPrice,config)=>{var _config$autoSell;if(!((_config$autoSell=config.autoSell)!==null&&_config$autoSell!==void 0&&_config$autoSell.enabled))return null;const priceChange=(currentPrice-buyPrice)/buyPrice*100;const{profitTarget,stopLoss,trailingStop,partialSelling}=config.autoSell;const strategy={shouldSell:false,sellPercentage:100,reason:'',urgency:'normal'};// Check stop-loss\nif(priceChange<=stopLoss){strategy.shouldSell=true;strategy.reason=`Stop-loss triggered at ${priceChange.toFixed(2)}%`;strategy.urgency='high';return strategy;}// Check take-profit\nif(priceChange>=profitTarget){strategy.shouldSell=true;strategy.reason=`Take-profit triggered at ${priceChange.toFixed(2)}%`;strategy.urgency='normal';return strategy;}// Check partial selling\nif(partialSelling.enabled&&partialSelling.priceTargets.length>0){for(let i=0;i<partialSelling.priceTargets.length;i++){const target=partialSelling.priceTargets[i];const percentage=partialSelling.percentages[i]||25;if(priceChange>=target){strategy.shouldSell=true;strategy.sellPercentage=percentage;strategy.reason=`Partial sell ${percentage}% at ${priceChange.toFixed(2)}%`;strategy.urgency='low';break;}}}// Check trailing stop\nif(trailingStop.enabled&&priceChange>=trailingStop.activationPrice){// This would need to track the highest price reached\n// For now, simplified logic\nconst trailingStopPrice=currentPrice*(1-trailingStop.percentage/100);if(currentPrice<=trailingStopPrice){strategy.shouldSell=true;strategy.reason=`Trailing stop triggered at ${priceChange.toFixed(2)}%`;strategy.urgency='high';}}return strategy;},[]);/**\n   * Transaction queue management with nonce handling\n   */const addToQueue=useCallback((snipeConfigId,type,priority,gasSettings)=>{const queueItem={id:`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,snipeConfigId,type,priority,nonce:nonceRef.current++,gasSettings,status:'queued',createdAt:Date.now(),retryCount:0};setTransactionQueue(prev=>{const newQueue=[...prev,queueItem];// Sort by priority (higher first), then by creation time\nreturn newQueue.sort((a,b)=>{if(a.priority!==b.priority)return b.priority-a.priority;return a.createdAt-b.createdAt;});});return queueItem.id;},[]);/**\n   * Process transaction queue with batch support\n   */const processQueue=useCallback(async()=>{if(processingQueue.current)return;processingQueue.current=true;try{const queuedItems=transactionQueue.filter(item=>item.status==='queued');if(queuedItems.length===0)return;// Process in batches\nconst batchSize=3;// Configurable batch size\nconst batch=queuedItems.slice(0,batchSize);for(const item of batch){setTransactionQueue(prev=>prev.map(qi=>qi.id===item.id?{...qi,status:'processing',executedAt:Date.now()}:qi));try{// Simulate transaction execution\nawait new Promise(resolve=>setTimeout(resolve,1000+Math.random()*2000));// Simulate success/failure\nconst success=Math.random()>0.1;// 90% success rate\nsetTransactionQueue(prev=>prev.map(qi=>qi.id===item.id?{...qi,status:success?'confirmed':'failed',retryCount:success?qi.retryCount:qi.retryCount+1}:qi));// If failed and under retry limit, requeue\nif(!success&&item.retryCount<3){setTimeout(()=>{setTransactionQueue(prev=>prev.map(qi=>qi.id===item.id?{...qi,status:'queued'}:qi));},5000);// Retry after 5 seconds\n}}catch(error){console.error('Transaction execution failed:',error);setTransactionQueue(prev=>prev.map(qi=>qi.id===item.id?{...qi,status:'failed',retryCount:qi.retryCount+1}:qi));}// Delay between batch transactions\nif(batch.indexOf(item)<batch.length-1){await new Promise(resolve=>setTimeout(resolve,200));}}}finally{processingQueue.current=false;}},[transactionQueue]);/**\n   * Update network statistics\n   */const updateNetworkStats=useCallback(()=>{setNetworkStats(prev=>({baseFee:prev.baseFee+(Math.random()-0.5)*5,fastGasPrice:prev.fastGasPrice+(Math.random()-0.5)*8,networkCongestion:['low','medium','high'][Math.floor(Math.random()*3)],avgBlockTime:12+(Math.random()-0.5)*4}));},[]);// Auto-process queue\nuseEffect(()=>{const interval=setInterval(processQueue,2000);return()=>clearInterval(interval);},[processQueue]);// Update network stats periodically\nuseEffect(()=>{const interval=setInterval(updateNetworkStats,10000);return()=>clearInterval(interval);},[updateNetworkStats]);// Clean up old transactions\nuseEffect(()=>{const cleanup=setInterval(()=>{setTransactionQueue(prev=>prev.filter(item=>Date.now()-item.createdAt<300000)// Keep last 5 minutes\n);},30000);return()=>clearInterval(cleanup);},[]);return{gasEstimations,transactionQueue,slippageCalculations,networkStats,estimateGas,calculateSmartSlippage,calculateExitStrategy,addToQueue,processQueue,updateNetworkStats};}","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","useAdvancedTrading","gasEstimations","setGasEstimations","Map","transactionQueue","setTransactionQueue","slippageCalculations","setSlippageCalculations","networkStats","setNetworkStats","baseFee","fastGasPrice","networkCongestion","avgBlockTime","nonceRef","processingQueue","estimateGas","tokenAddress","amount","priorityFee","Math","max","maxFeePerGas","gasLimit","floor","random","estimation","maxPriorityFeePerGas","estimatedCost","executionTime","confidence","prev","set","error","console","calculateSmartSlippage","baseSlippage","maxSlippage","liquidityThreshold","volatilityMultiplier","liquidity","volatility","volume24h","liquidityFactor","min","volatilityFactor","volumeFactor","adjustedSlippage","recommendedSlippage","calculation","calculateExitStrategy","buyPrice","currentPrice","config","_config$autoSell","autoSell","enabled","priceChange","profitTarget","stopLoss","trailingStop","partialSelling","strategy","shouldSell","sellPercentage","reason","urgency","toFixed","priceTargets","length","i","target","percentage","percentages","activationPrice","trailingStopPrice","addToQueue","snipeConfigId","type","priority","gasSettings","queueItem","id","Date","now","toString","substr","nonce","current","status","createdAt","retryCount","newQueue","sort","a","b","processQueue","queuedItems","filter","item","batchSize","batch","slice","map","qi","executedAt","Promise","resolve","setTimeout","success","indexOf","updateNetworkStats","interval","setInterval","clearInterval","cleanup"],"sources":["C:/Users/tpars/source/repos/Crypto Sniper Pro_ AI-Powered Ethereum Trading App/src/hooks/useAdvancedTrading.ts"],"sourcesContent":["/**\n * Advanced trading hook with gas estimation, smart slippage, and batch processing\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { GasEstimation, TransactionQueueItem, SlippageCalculation, SnipeConfig } from '../types/trading';\n\nexport function useAdvancedTrading() {\n  const [gasEstimations, setGasEstimations] = useState<Map<string, GasEstimation>>(new Map());\n  const [transactionQueue, setTransactionQueue] = useState<TransactionQueueItem[]>([]);\n  const [slippageCalculations, setSlippageCalculations] = useState<Map<string, SlippageCalculation>>(new Map());\n  const [networkStats, setNetworkStats] = useState({\n    baseFee: 15,\n    fastGasPrice: 25,\n    networkCongestion: 'medium' as 'low' | 'medium' | 'high',\n    avgBlockTime: 12,\n  });\n\n  const nonceRef = useRef<number>(0);\n  const processingQueue = useRef<boolean>(false);\n\n  /**\n   * Dynamic gas fee estimation with EIP-1559 support\n   */\n  const estimateGas = useCallback(async (tokenAddress: string, amount: number): Promise<GasEstimation> => {\n    try {\n      // Simulate gas estimation (in production, this would call actual RPC)\n      const baseFee = networkStats.baseFee;\n      const priorityFee = Math.max(2, baseFee * 0.1);\n      const maxFeePerGas = baseFee * 2 + priorityFee;\n      const gasLimit = 150000 + Math.floor(Math.random() * 50000);\n      \n      const estimation: GasEstimation = {\n        baseFee,\n        maxFeePerGas,\n        maxPriorityFeePerGas: priorityFee,\n        gasLimit,\n        estimatedCost: (maxFeePerGas * gasLimit) / 1e18,\n        executionTime: networkStats.avgBlockTime + (networkStats.networkCongestion === 'high' ? 20 : \n                       networkStats.networkCongestion === 'medium' ? 10 : 5),\n        confidence: Math.random() * 0.3 + 0.7, // 70-100% confidence\n      };\n\n      setGasEstimations(prev => new Map(prev.set(tokenAddress, estimation)));\n      return estimation;\n    } catch (error) {\n      console.error('Gas estimation failed:', error);\n      throw error;\n    }\n  }, [networkStats]);\n\n  /**\n   * Smart slippage adjustment based on liquidity and volatility\n   */\n  const calculateSmartSlippage = useCallback((\n    tokenAddress: string,\n    baseSlippage: number,\n    maxSlippage: number,\n    liquidityThreshold: number,\n    volatilityMultiplier: number\n  ): SlippageCalculation => {\n    // Simulate market conditions\n    const liquidity = Math.random() * 5000000 + 100000; // $100K - $5M\n    const volatility = Math.random() * 50 + 5; // 5% - 55%\n    const volume24h = Math.random() * 1000000 + 10000; // $10K - $1M\n\n    // Calculate adjustment factors\n    const liquidityFactor = Math.max(0.5, Math.min(2, liquidityThreshold / liquidity));\n    const volatilityFactor = Math.max(0.5, Math.min(3, volatility / 20));\n    const volumeFactor = Math.max(0.8, Math.min(1.5, volume24h / 500000));\n\n    // Calculate adjusted slippage\n    const adjustedSlippage = baseSlippage * liquidityFactor * volatilityFactor * volumeFactor * volatilityMultiplier;\n    const recommendedSlippage = Math.min(maxSlippage, Math.max(baseSlippage * 0.5, adjustedSlippage));\n\n    const calculation: SlippageCalculation = {\n      baseSlippage,\n      adjustedSlippage,\n      liquidityFactor,\n      volatilityFactor,\n      recommendedSlippage,\n      confidence: Math.random() * 0.4 + 0.6, // 60-100% confidence\n    };\n\n    setSlippageCalculations(prev => new Map(prev.set(tokenAddress, calculation)));\n    return calculation;\n  }, []);\n\n  /**\n   * Advanced stop-loss and take-profit logic\n   */\n  const calculateExitStrategy = useCallback((\n    buyPrice: number,\n    currentPrice: number,\n    config: SnipeConfig\n  ) => {\n    if (!config.autoSell?.enabled) return null;\n\n    const priceChange = ((currentPrice - buyPrice) / buyPrice) * 100;\n    const { profitTarget, stopLoss, trailingStop, partialSelling } = config.autoSell;\n\n    const strategy = {\n      shouldSell: false,\n      sellPercentage: 100,\n      reason: '',\n      urgency: 'normal' as 'low' | 'normal' | 'high',\n    };\n\n    // Check stop-loss\n    if (priceChange <= stopLoss) {\n      strategy.shouldSell = true;\n      strategy.reason = `Stop-loss triggered at ${priceChange.toFixed(2)}%`;\n      strategy.urgency = 'high';\n      return strategy;\n    }\n\n    // Check take-profit\n    if (priceChange >= profitTarget) {\n      strategy.shouldSell = true;\n      strategy.reason = `Take-profit triggered at ${priceChange.toFixed(2)}%`;\n      strategy.urgency = 'normal';\n      return strategy;\n    }\n\n    // Check partial selling\n    if (partialSelling.enabled && partialSelling.priceTargets.length > 0) {\n      for (let i = 0; i < partialSelling.priceTargets.length; i++) {\n        const target = partialSelling.priceTargets[i];\n        const percentage = partialSelling.percentages[i] || 25;\n        \n        if (priceChange >= target) {\n          strategy.shouldSell = true;\n          strategy.sellPercentage = percentage;\n          strategy.reason = `Partial sell ${percentage}% at ${priceChange.toFixed(2)}%`;\n          strategy.urgency = 'low';\n          break;\n        }\n      }\n    }\n\n    // Check trailing stop\n    if (trailingStop.enabled && priceChange >= trailingStop.activationPrice) {\n      // This would need to track the highest price reached\n      // For now, simplified logic\n      const trailingStopPrice = currentPrice * (1 - trailingStop.percentage / 100);\n      if (currentPrice <= trailingStopPrice) {\n        strategy.shouldSell = true;\n        strategy.reason = `Trailing stop triggered at ${priceChange.toFixed(2)}%`;\n        strategy.urgency = 'high';\n      }\n    }\n\n    return strategy;\n  }, []);\n\n  /**\n   * Transaction queue management with nonce handling\n   */\n  const addToQueue = useCallback((\n    snipeConfigId: string,\n    type: 'buy' | 'sell',\n    priority: number,\n    gasSettings: GasEstimation\n  ) => {\n    const queueItem: TransactionQueueItem = {\n      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      snipeConfigId,\n      type,\n      priority,\n      nonce: nonceRef.current++,\n      gasSettings,\n      status: 'queued',\n      createdAt: Date.now(),\n      retryCount: 0,\n    };\n\n    setTransactionQueue(prev => {\n      const newQueue = [...prev, queueItem];\n      // Sort by priority (higher first), then by creation time\n      return newQueue.sort((a, b) => {\n        if (a.priority !== b.priority) return b.priority - a.priority;\n        return a.createdAt - b.createdAt;\n      });\n    });\n\n    return queueItem.id;\n  }, []);\n\n  /**\n   * Process transaction queue with batch support\n   */\n  const processQueue = useCallback(async () => {\n    if (processingQueue.current) return;\n    processingQueue.current = true;\n\n    try {\n      const queuedItems = transactionQueue.filter(item => item.status === 'queued');\n      if (queuedItems.length === 0) return;\n\n      // Process in batches\n      const batchSize = 3; // Configurable batch size\n      const batch = queuedItems.slice(0, batchSize);\n\n      for (const item of batch) {\n        setTransactionQueue(prev => \n          prev.map(qi => \n            qi.id === item.id ? { ...qi, status: 'processing', executedAt: Date.now() } : qi\n          )\n        );\n\n        try {\n          // Simulate transaction execution\n          await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n          \n          // Simulate success/failure\n          const success = Math.random() > 0.1; // 90% success rate\n          \n          setTransactionQueue(prev => \n            prev.map(qi => \n              qi.id === item.id ? { \n                ...qi, \n                status: success ? 'confirmed' : 'failed',\n                retryCount: success ? qi.retryCount : qi.retryCount + 1\n              } : qi\n            )\n          );\n\n          // If failed and under retry limit, requeue\n          if (!success && item.retryCount < 3) {\n            setTimeout(() => {\n              setTransactionQueue(prev => \n                prev.map(qi => \n                  qi.id === item.id ? { ...qi, status: 'queued' } : qi\n                )\n              );\n            }, 5000); // Retry after 5 seconds\n          }\n\n        } catch (error) {\n          console.error('Transaction execution failed:', error);\n          setTransactionQueue(prev => \n            prev.map(qi => \n              qi.id === item.id ? { ...qi, status: 'failed', retryCount: qi.retryCount + 1 } : qi\n            )\n          );\n        }\n\n        // Delay between batch transactions\n        if (batch.indexOf(item) < batch.length - 1) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n        }\n      }\n    } finally {\n      processingQueue.current = false;\n    }\n  }, [transactionQueue]);\n\n  /**\n   * Update network statistics\n   */\n  const updateNetworkStats = useCallback(() => {\n    setNetworkStats(prev => ({\n      baseFee: prev.baseFee + (Math.random() - 0.5) * 5,\n      fastGasPrice: prev.fastGasPrice + (Math.random() - 0.5) * 8,\n      networkCongestion: (['low', 'medium', 'high'][Math.floor(Math.random() * 3)] as 'low' | 'medium' | 'high'),\n      avgBlockTime: 12 + (Math.random() - 0.5) * 4,\n    }));\n  }, []);\n\n  // Auto-process queue\n  useEffect(() => {\n    const interval = setInterval(processQueue, 2000);\n    return () => clearInterval(interval);\n  }, [processQueue]);\n\n  // Update network stats periodically\n  useEffect(() => {\n    const interval = setInterval(updateNetworkStats, 10000);\n    return () => clearInterval(interval);\n  }, [updateNetworkStats]);\n\n  // Clean up old transactions\n  useEffect(() => {\n    const cleanup = setInterval(() => {\n      setTransactionQueue(prev => \n        prev.filter(item => Date.now() - item.createdAt < 300000) // Keep last 5 minutes\n      );\n    }, 30000);\n\n    return () => clearInterval(cleanup);\n  }, []);\n\n  return {\n    gasEstimations,\n    transactionQueue,\n    slippageCalculations,\n    networkStats,\n    estimateGas,\n    calculateSmartSlippage,\n    calculateExitStrategy,\n    addToQueue,\n    processQueue,\n    updateNetworkStats,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}