{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * Subscription management hook\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { SUBSCRIPTION_PLANS } from '../types/subscription';\nexport function useSubscription(userId) {\n  _s();\n  const [subscription, setSubscription] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Get current subscription plan\n  const plan = subscription ? SUBSCRIPTION_PLANS[subscription.planId] || SUBSCRIPTION_PLANS.free : SUBSCRIPTION_PLANS.free;\n\n  /**\n   * Load subscription data from storage/API\n   */\n  const loadSubscription = useCallback(async () => {\n    if (!userId) {\n      setSubscription(null);\n      setLoading(false);\n      return;\n    }\n    try {\n      setLoading(true);\n\n      // Check localStorage first\n      const stored = localStorage.getItem(`cryptosniper_subscription_${userId}`);\n      if (stored) {\n        const sub = JSON.parse(stored);\n        // Validate subscription is still active\n        if (sub.currentPeriodEnd > Date.now() && sub.status === 'active') {\n          setSubscription(sub);\n          setLoading(false);\n          return;\n        }\n      }\n\n      // For creator account, give premium access\n      if (userId === 'creator_admin_001') {\n        const creatorSub = {\n          id: 'creator_subscription',\n          userId: userId,\n          planId: 'premium',\n          status: 'active',\n          currentPeriodStart: Date.now(),\n          currentPeriodEnd: Date.now() + 365 * 24 * 60 * 60 * 1000,\n          // 1 year\n          cancelAtPeriodEnd: false,\n          createdAt: Date.now(),\n          updatedAt: Date.now()\n        };\n        setSubscription(creatorSub);\n        localStorage.setItem(`cryptosniper_subscription_${userId}`, JSON.stringify(creatorSub));\n      } else {\n        // Regular users default to free plan\n        setSubscription(null);\n      }\n    } catch (err) {\n      console.error('Error loading subscription:', err);\n      setError('Failed to load subscription data');\n    } finally {\n      setLoading(false);\n    }\n  }, [userId]);\n  useEffect(() => {\n    loadSubscription();\n  }, [loadSubscription]);\n\n  /**\n   * Check if user can access a specific feature\n   */\n  const canAccessFeature = useCallback(feature => {\n    return plan.limits[feature];\n  }, [plan]);\n\n  /**\n   * Upgrade to Pro plan\n   */\n  const upgradeToProPlan = useCallback(async () => {\n    if (!userId) return null;\n    try {\n      setLoading(true);\n\n      // Create payment intent for Pro plan\n      const paymentIntent = {\n        id: `pi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        amount: SUBSCRIPTION_PLANS.pro.price * 100,\n        // Amount in cents\n        currency: 'usd',\n        status: 'requires_payment_method',\n        metadata: {\n          userId,\n          planId: 'pro',\n          upgrade: true\n        }\n      };\n\n      // In production, this would call your payment processor (Stripe, etc.)\n      // For now, we'll simulate successful payment\n      setTimeout(() => {\n        const newSubscription = {\n          id: `sub_${Date.now()}`,\n          userId,\n          planId: 'pro',\n          status: 'active',\n          currentPeriodStart: Date.now(),\n          currentPeriodEnd: Date.now() + 30 * 24 * 60 * 60 * 1000,\n          // 30 days\n          cancelAtPeriodEnd: false,\n          createdAt: Date.now(),\n          updatedAt: Date.now()\n        };\n        setSubscription(newSubscription);\n        localStorage.setItem(`cryptosniper_subscription_${userId}`, JSON.stringify(newSubscription));\n      }, 2000);\n      return paymentIntent;\n    } catch (err) {\n      console.error('Error upgrading to Pro:', err);\n      setError('Failed to upgrade subscription');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [userId]);\n\n  /**\n   * Upgrade to Premium plan\n   */\n  const upgradeToPremiumPlan = useCallback(async () => {\n    if (!userId) return null;\n    try {\n      setLoading(true);\n      const paymentIntent = {\n        id: `pi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        amount: SUBSCRIPTION_PLANS.premium.price * 100,\n        currency: 'usd',\n        status: 'requires_payment_method',\n        metadata: {\n          userId,\n          planId: 'premium',\n          upgrade: true\n        }\n      };\n\n      // Simulate payment processing\n      setTimeout(() => {\n        const newSubscription = {\n          id: `sub_${Date.now()}`,\n          userId,\n          planId: 'premium',\n          status: 'active',\n          currentPeriodStart: Date.now(),\n          currentPeriodEnd: Date.now() + 30 * 24 * 60 * 60 * 1000,\n          cancelAtPeriodEnd: false,\n          createdAt: Date.now(),\n          updatedAt: Date.now()\n        };\n        setSubscription(newSubscription);\n        localStorage.setItem(`cryptosniper_subscription_${userId}`, JSON.stringify(newSubscription));\n      }, 2000);\n      return paymentIntent;\n    } catch (err) {\n      console.error('Error upgrading to Premium:', err);\n      setError('Failed to upgrade subscription');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [userId]);\n\n  /**\n   * Cancel subscription\n   */\n  const cancelSubscription = useCallback(async () => {\n    if (!subscription) return false;\n    try {\n      setLoading(true);\n      const updatedSubscription = {\n        ...subscription,\n        cancelAtPeriodEnd: true,\n        updatedAt: Date.now()\n      };\n      setSubscription(updatedSubscription);\n      localStorage.setItem(`cryptosniper_subscription_${userId}`, JSON.stringify(updatedSubscription));\n      return true;\n    } catch (err) {\n      console.error('Error canceling subscription:', err);\n      setError('Failed to cancel subscription');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [subscription, userId]);\n\n  /**\n   * Update payment method\n   */\n  const updatePaymentMethod = useCallback(async paymentMethodId => {\n    if (!subscription) return false;\n    try {\n      setLoading(true);\n\n      // Update payment method logic would go here\n      // For now, just return success\n      return true;\n    } catch (err) {\n      console.error('Error updating payment method:', err);\n      setError('Failed to update payment method');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [subscription]);\n  return {\n    subscription,\n    plan,\n    loading,\n    error,\n    canAccessFeature,\n    upgradeToProPlan,\n    upgradeToPremiumPlan,\n    cancelSubscription,\n    updatePaymentMethod\n  };\n}\n_s(useSubscription, \"MzMzYoqm4GdRTQDQ12Ecli8U4RQ=\");\nexport default useSubscription;","map":{"version":3,"names":["useState","useEffect","useCallback","SUBSCRIPTION_PLANS","useSubscription","userId","_s","subscription","setSubscription","loading","setLoading","error","setError","plan","planId","free","loadSubscription","stored","localStorage","getItem","sub","JSON","parse","currentPeriodEnd","Date","now","status","creatorSub","id","currentPeriodStart","cancelAtPeriodEnd","createdAt","updatedAt","setItem","stringify","err","console","canAccessFeature","feature","limits","upgradeToProPlan","paymentIntent","Math","random","toString","substr","amount","pro","price","currency","metadata","upgrade","setTimeout","newSubscription","upgradeToPremiumPlan","premium","cancelSubscription","updatedSubscription","updatePaymentMethod","paymentMethodId"],"sources":["C:/Users/tpars/source/repos/Crypto Sniper Pro_ AI-Powered Ethereum Trading App/src/hooks/useSubscription.ts"],"sourcesContent":["/**\n * Subscription management hook\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { SUBSCRIPTION_PLANS, type Subscription, type SubscriptionPlan, type PaymentIntent } from '../types/subscription';\n\ninterface SubscriptionContextType {\n  subscription: Subscription | null;\n  plan: SubscriptionPlan;\n  loading: boolean;\n  error: string | null;\n  canAccessFeature: (feature: keyof SubscriptionPlan['limits']) => boolean;\n  upgradeToProPlan: () => Promise<PaymentIntent | null>;\n  upgradeToPremiumPlan: () => Promise<PaymentIntent | null>;\n  cancelSubscription: () => Promise<boolean>;\n  updatePaymentMethod: (paymentMethodId: string) => Promise<boolean>;\n}\n\nexport function useSubscription(userId?: string): SubscriptionContextType {\n  const [subscription, setSubscription] = useState<Subscription | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Get current subscription plan\n  const plan = subscription ? SUBSCRIPTION_PLANS[subscription.planId] || SUBSCRIPTION_PLANS.free : SUBSCRIPTION_PLANS.free;\n\n  /**\n   * Load subscription data from storage/API\n   */\n  const loadSubscription = useCallback(async () => {\n    if (!userId) {\n      setSubscription(null);\n      setLoading(false);\n      return;\n    }\n\n    try {\n      setLoading(true);\n      \n      // Check localStorage first\n      const stored = localStorage.getItem(`cryptosniper_subscription_${userId}`);\n      if (stored) {\n        const sub = JSON.parse(stored);\n        // Validate subscription is still active\n        if (sub.currentPeriodEnd > Date.now() && sub.status === 'active') {\n          setSubscription(sub);\n          setLoading(false);\n          return;\n        }\n      }\n\n      // For creator account, give premium access\n      if (userId === 'creator_admin_001') {\n        const creatorSub: Subscription = {\n          id: 'creator_subscription',\n          userId: userId,\n          planId: 'premium',\n          status: 'active',\n          currentPeriodStart: Date.now(),\n          currentPeriodEnd: Date.now() + (365 * 24 * 60 * 60 * 1000), // 1 year\n          cancelAtPeriodEnd: false,\n          createdAt: Date.now(),\n          updatedAt: Date.now()\n        };\n        setSubscription(creatorSub);\n        localStorage.setItem(`cryptosniper_subscription_${userId}`, JSON.stringify(creatorSub));\n      } else {\n        // Regular users default to free plan\n        setSubscription(null);\n      }\n\n    } catch (err) {\n      console.error('Error loading subscription:', err);\n      setError('Failed to load subscription data');\n    } finally {\n      setLoading(false);\n    }\n  }, [userId]);\n\n  useEffect(() => {\n    loadSubscription();\n  }, [loadSubscription]);\n\n  /**\n   * Check if user can access a specific feature\n   */\n  const canAccessFeature = useCallback((feature: keyof SubscriptionPlan['limits']): boolean => {\n    return plan.limits[feature] as boolean;\n  }, [plan]);\n\n  /**\n   * Upgrade to Pro plan\n   */\n  const upgradeToProPlan = useCallback(async (): Promise<PaymentIntent | null> => {\n    if (!userId) return null;\n\n    try {\n      setLoading(true);\n      \n      // Create payment intent for Pro plan\n      const paymentIntent: PaymentIntent = {\n        id: `pi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        amount: SUBSCRIPTION_PLANS.pro.price * 100, // Amount in cents\n        currency: 'usd',\n        status: 'requires_payment_method',\n        metadata: {\n          userId,\n          planId: 'pro',\n          upgrade: true\n        }\n      };\n\n      // In production, this would call your payment processor (Stripe, etc.)\n      // For now, we'll simulate successful payment\n      setTimeout(() => {\n        const newSubscription: Subscription = {\n          id: `sub_${Date.now()}`,\n          userId,\n          planId: 'pro',\n          status: 'active',\n          currentPeriodStart: Date.now(),\n          currentPeriodEnd: Date.now() + (30 * 24 * 60 * 60 * 1000), // 30 days\n          cancelAtPeriodEnd: false,\n          createdAt: Date.now(),\n          updatedAt: Date.now()\n        };\n\n        setSubscription(newSubscription);\n        localStorage.setItem(`cryptosniper_subscription_${userId}`, JSON.stringify(newSubscription));\n      }, 2000);\n\n      return paymentIntent;\n\n    } catch (err) {\n      console.error('Error upgrading to Pro:', err);\n      setError('Failed to upgrade subscription');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [userId]);\n\n  /**\n   * Upgrade to Premium plan\n   */\n  const upgradeToPremiumPlan = useCallback(async (): Promise<PaymentIntent | null> => {\n    if (!userId) return null;\n\n    try {\n      setLoading(true);\n      \n      const paymentIntent: PaymentIntent = {\n        id: `pi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        amount: SUBSCRIPTION_PLANS.premium.price * 100,\n        currency: 'usd',\n        status: 'requires_payment_method',\n        metadata: {\n          userId,\n          planId: 'premium',\n          upgrade: true\n        }\n      };\n\n      // Simulate payment processing\n      setTimeout(() => {\n        const newSubscription: Subscription = {\n          id: `sub_${Date.now()}`,\n          userId,\n          planId: 'premium',\n          status: 'active',\n          currentPeriodStart: Date.now(),\n          currentPeriodEnd: Date.now() + (30 * 24 * 60 * 60 * 1000),\n          cancelAtPeriodEnd: false,\n          createdAt: Date.now(),\n          updatedAt: Date.now()\n        };\n\n        setSubscription(newSubscription);\n        localStorage.setItem(`cryptosniper_subscription_${userId}`, JSON.stringify(newSubscription));\n      }, 2000);\n\n      return paymentIntent;\n\n    } catch (err) {\n      console.error('Error upgrading to Premium:', err);\n      setError('Failed to upgrade subscription');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [userId]);\n\n  /**\n   * Cancel subscription\n   */\n  const cancelSubscription = useCallback(async (): Promise<boolean> => {\n    if (!subscription) return false;\n\n    try {\n      setLoading(true);\n      \n      const updatedSubscription = {\n        ...subscription,\n        cancelAtPeriodEnd: true,\n        updatedAt: Date.now()\n      };\n\n      setSubscription(updatedSubscription);\n      localStorage.setItem(`cryptosniper_subscription_${userId}`, JSON.stringify(updatedSubscription));\n      \n      return true;\n\n    } catch (err) {\n      console.error('Error canceling subscription:', err);\n      setError('Failed to cancel subscription');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [subscription, userId]);\n\n  /**\n   * Update payment method\n   */\n  const updatePaymentMethod = useCallback(async (paymentMethodId: string): Promise<boolean> => {\n    if (!subscription) return false;\n\n    try {\n      setLoading(true);\n      \n      // Update payment method logic would go here\n      // For now, just return success\n      return true;\n\n    } catch (err) {\n      console.error('Error updating payment method:', err);\n      setError('Failed to update payment method');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [subscription]);\n\n  return {\n    subscription,\n    plan,\n    loading,\n    error,\n    canAccessFeature,\n    upgradeToProPlan,\n    upgradeToPremiumPlan,\n    cancelSubscription,\n    updatePaymentMethod\n  };\n}\n\nexport default useSubscription;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}