{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * Advanced trading hook with gas estimation, smart slippage, and batch processing\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nexport function useAdvancedTrading() {\n  _s();\n  const [gasEstimations, setGasEstimations] = useState(new Map());\n  const [transactionQueue, setTransactionQueue] = useState([]);\n  const [slippageCalculations, setSlippageCalculations] = useState(new Map());\n  const [networkStats, setNetworkStats] = useState({\n    baseFee: 15,\n    fastGasPrice: 25,\n    networkCongestion: 'medium',\n    avgBlockTime: 12\n  });\n  const nonceRef = useRef(0);\n  const processingQueue = useRef(false);\n\n  /**\n   * Dynamic gas fee estimation with EIP-1559 support\n   */\n  const estimateGas = useCallback(async (tokenAddress, amount) => {\n    try {\n      // Simulate gas estimation (in production, this would call actual RPC)\n      const baseFee = networkStats.baseFee;\n      const priorityFee = Math.max(2, baseFee * 0.1);\n      const maxFeePerGas = baseFee * 2 + priorityFee;\n      const gasLimit = 150000 + Math.floor(Math.random() * 50000);\n      const estimation = {\n        baseFee,\n        maxFeePerGas,\n        maxPriorityFeePerGas: priorityFee,\n        gasLimit,\n        estimatedCost: maxFeePerGas * gasLimit / 1e18,\n        executionTime: networkStats.avgBlockTime + (networkStats.networkCongestion === 'high' ? 20 : networkStats.networkCongestion === 'medium' ? 10 : 5),\n        confidence: Math.random() * 0.3 + 0.7 // 70-100% confidence\n      };\n      setGasEstimations(prev => new Map(prev.set(tokenAddress, estimation)));\n      return estimation;\n    } catch (error) {\n      console.error('Gas estimation failed:', error);\n      throw error;\n    }\n  }, [networkStats]);\n\n  /**\n   * Smart slippage adjustment based on liquidity and volatility\n   */\n  const calculateSmartSlippage = useCallback((tokenAddress, baseSlippage, maxSlippage, liquidityThreshold, volatilityMultiplier) => {\n    // Simulate market conditions\n    const liquidity = Math.random() * 5000000 + 100000; // $100K - $5M\n    const volatility = Math.random() * 50 + 5; // 5% - 55%\n    const volume24h = Math.random() * 1000000 + 10000; // $10K - $1M\n\n    // Calculate adjustment factors\n    const liquidityFactor = Math.max(0.5, Math.min(2, liquidityThreshold / liquidity));\n    const volatilityFactor = Math.max(0.5, Math.min(3, volatility / 20));\n    const volumeFactor = Math.max(0.8, Math.min(1.5, volume24h / 500000));\n\n    // Calculate adjusted slippage\n    const adjustedSlippage = baseSlippage * liquidityFactor * volatilityFactor * volumeFactor * volatilityMultiplier;\n    const recommendedSlippage = Math.min(maxSlippage, Math.max(baseSlippage * 0.5, adjustedSlippage));\n    const calculation = {\n      baseSlippage,\n      adjustedSlippage,\n      liquidityFactor,\n      volatilityFactor,\n      recommendedSlippage,\n      confidence: Math.random() * 0.4 + 0.6 // 60-100% confidence\n    };\n    setSlippageCalculations(prev => new Map(prev.set(tokenAddress, calculation)));\n    return calculation;\n  }, []);\n\n  /**\n   * Advanced stop-loss and take-profit logic\n   */\n  const calculateExitStrategy = useCallback((buyPrice, currentPrice, config) => {\n    var _config$autoSell;\n    if (!((_config$autoSell = config.autoSell) !== null && _config$autoSell !== void 0 && _config$autoSell.enabled)) return null;\n    const priceChange = (currentPrice - buyPrice) / buyPrice * 100;\n    const {\n      profitTarget,\n      stopLoss,\n      trailingStop,\n      partialSelling\n    } = config.autoSell;\n    const strategy = {\n      shouldSell: false,\n      sellPercentage: 100,\n      reason: '',\n      urgency: 'normal'\n    };\n\n    // Check stop-loss\n    if (priceChange <= stopLoss) {\n      strategy.shouldSell = true;\n      strategy.reason = `Stop-loss triggered at ${priceChange.toFixed(2)}%`;\n      strategy.urgency = 'high';\n      return strategy;\n    }\n\n    // Check take-profit\n    if (priceChange >= profitTarget) {\n      strategy.shouldSell = true;\n      strategy.reason = `Take-profit triggered at ${priceChange.toFixed(2)}%`;\n      strategy.urgency = 'normal';\n      return strategy;\n    }\n\n    // Check partial selling\n    if (partialSelling.enabled && partialSelling.priceTargets.length > 0) {\n      for (let i = 0; i < partialSelling.priceTargets.length; i++) {\n        const target = partialSelling.priceTargets[i];\n        const percentage = partialSelling.percentages[i] || 25;\n        if (priceChange >= target) {\n          strategy.shouldSell = true;\n          strategy.sellPercentage = percentage;\n          strategy.reason = `Partial sell ${percentage}% at ${priceChange.toFixed(2)}%`;\n          strategy.urgency = 'low';\n          break;\n        }\n      }\n    }\n\n    // Check trailing stop\n    if (trailingStop.enabled && priceChange >= trailingStop.activationPrice) {\n      // This would need to track the highest price reached\n      // For now, simplified logic\n      const trailingStopPrice = currentPrice * (1 - trailingStop.percentage / 100);\n      if (currentPrice <= trailingStopPrice) {\n        strategy.shouldSell = true;\n        strategy.reason = `Trailing stop triggered at ${priceChange.toFixed(2)}%`;\n        strategy.urgency = 'high';\n      }\n    }\n    return strategy;\n  }, []);\n\n  /**\n   * Transaction queue management with nonce handling\n   */\n  const addToQueue = useCallback((snipeConfigId, type, priority, gasSettings) => {\n    const queueItem = {\n      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      snipeConfigId,\n      type,\n      priority,\n      nonce: nonceRef.current++,\n      gasSettings,\n      status: 'queued',\n      createdAt: Date.now(),\n      retryCount: 0\n    };\n    setTransactionQueue(prev => {\n      const newQueue = [...prev, queueItem];\n      // Sort by priority (higher first), then by creation time\n      return newQueue.sort((a, b) => {\n        if (a.priority !== b.priority) return b.priority - a.priority;\n        return a.createdAt - b.createdAt;\n      });\n    });\n    return queueItem.id;\n  }, []);\n\n  /**\n   * Process transaction queue with batch support\n   */\n  const processQueue = useCallback(async () => {\n    if (processingQueue.current) return;\n    processingQueue.current = true;\n    try {\n      const queuedItems = transactionQueue.filter(item => item.status === 'queued');\n      if (queuedItems.length === 0) return;\n\n      // Process in batches\n      const batchSize = 3; // Configurable batch size\n      const batch = queuedItems.slice(0, batchSize);\n      for (const item of batch) {\n        setTransactionQueue(prev => prev.map(qi => qi.id === item.id ? {\n          ...qi,\n          status: 'processing',\n          executedAt: Date.now()\n        } : qi));\n        try {\n          // Simulate transaction execution\n          await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n\n          // Simulate success/failure\n          const success = Math.random() > 0.1; // 90% success rate\n\n          setTransactionQueue(prev => prev.map(qi => qi.id === item.id ? {\n            ...qi,\n            status: success ? 'confirmed' : 'failed',\n            retryCount: success ? qi.retryCount : qi.retryCount + 1\n          } : qi));\n\n          // If failed and under retry limit, requeue\n          if (!success && item.retryCount < 3) {\n            setTimeout(() => {\n              setTransactionQueue(prev => prev.map(qi => qi.id === item.id ? {\n                ...qi,\n                status: 'queued'\n              } : qi));\n            }, 5000); // Retry after 5 seconds\n          }\n        } catch (error) {\n          console.error('Transaction execution failed:', error);\n          setTransactionQueue(prev => prev.map(qi => qi.id === item.id ? {\n            ...qi,\n            status: 'failed',\n            retryCount: qi.retryCount + 1\n          } : qi));\n        }\n\n        // Delay between batch transactions\n        if (batch.indexOf(item) < batch.length - 1) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n        }\n      }\n    } finally {\n      processingQueue.current = false;\n    }\n  }, [transactionQueue]);\n\n  /**\n   * Update network statistics\n   */\n  const updateNetworkStats = useCallback(() => {\n    setNetworkStats(prev => ({\n      baseFee: prev.baseFee + (Math.random() - 0.5) * 5,\n      fastGasPrice: prev.fastGasPrice + (Math.random() - 0.5) * 8,\n      networkCongestion: ['low', 'medium', 'high'][Math.floor(Math.random() * 3)],\n      avgBlockTime: 12 + (Math.random() - 0.5) * 4\n    }));\n  }, []);\n\n  // Auto-process queue\n  useEffect(() => {\n    const interval = setInterval(processQueue, 2000);\n    return () => clearInterval(interval);\n  }, [processQueue]);\n\n  // Update network stats periodically\n  useEffect(() => {\n    const interval = setInterval(updateNetworkStats, 10000);\n    return () => clearInterval(interval);\n  }, [updateNetworkStats]);\n\n  // Clean up old transactions\n  useEffect(() => {\n    const cleanup = setInterval(() => {\n      setTransactionQueue(prev => prev.filter(item => Date.now() - item.createdAt < 300000) // Keep last 5 minutes\n      );\n    }, 30000);\n    return () => clearInterval(cleanup);\n  }, []);\n  return {\n    gasEstimations,\n    transactionQueue,\n    slippageCalculations,\n    networkStats,\n    estimateGas,\n    calculateSmartSlippage,\n    calculateExitStrategy,\n    addToQueue,\n    processQueue,\n    updateNetworkStats\n  };\n}\n_s(useAdvancedTrading, \"x9USW1+4p2dLJO/2OYfxdNtj35M=\");","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","useAdvancedTrading","_s","gasEstimations","setGasEstimations","Map","transactionQueue","setTransactionQueue","slippageCalculations","setSlippageCalculations","networkStats","setNetworkStats","baseFee","fastGasPrice","networkCongestion","avgBlockTime","nonceRef","processingQueue","estimateGas","tokenAddress","amount","priorityFee","Math","max","maxFeePerGas","gasLimit","floor","random","estimation","maxPriorityFeePerGas","estimatedCost","executionTime","confidence","prev","set","error","console","calculateSmartSlippage","baseSlippage","maxSlippage","liquidityThreshold","volatilityMultiplier","liquidity","volatility","volume24h","liquidityFactor","min","volatilityFactor","volumeFactor","adjustedSlippage","recommendedSlippage","calculation","calculateExitStrategy","buyPrice","currentPrice","config","_config$autoSell","autoSell","enabled","priceChange","profitTarget","stopLoss","trailingStop","partialSelling","strategy","shouldSell","sellPercentage","reason","urgency","toFixed","priceTargets","length","i","target","percentage","percentages","activationPrice","trailingStopPrice","addToQueue","snipeConfigId","type","priority","gasSettings","queueItem","id","Date","now","toString","substr","nonce","current","status","createdAt","retryCount","newQueue","sort","a","b","processQueue","queuedItems","filter","item","batchSize","batch","slice","map","qi","executedAt","Promise","resolve","setTimeout","success","indexOf","updateNetworkStats","interval","setInterval","clearInterval","cleanup"],"sources":["C:/Users/tpars/source/repos/Crypto Sniper Pro_ AI-Powered Ethereum Trading App/src/hooks/useAdvancedTrading.ts"],"sourcesContent":["/**\n * Advanced trading hook with gas estimation, smart slippage, and batch processing\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { GasEstimation, TransactionQueueItem, SlippageCalculation, SnipeConfig } from '../types/trading';\n\nexport function useAdvancedTrading() {\n  const [gasEstimations, setGasEstimations] = useState<Map<string, GasEstimation>>(new Map());\n  const [transactionQueue, setTransactionQueue] = useState<TransactionQueueItem[]>([]);\n  const [slippageCalculations, setSlippageCalculations] = useState<Map<string, SlippageCalculation>>(new Map());\n  const [networkStats, setNetworkStats] = useState({\n    baseFee: 15,\n    fastGasPrice: 25,\n    networkCongestion: 'medium' as 'low' | 'medium' | 'high',\n    avgBlockTime: 12,\n  });\n\n  const nonceRef = useRef<number>(0);\n  const processingQueue = useRef<boolean>(false);\n\n  /**\n   * Dynamic gas fee estimation with EIP-1559 support\n   */\n  const estimateGas = useCallback(async (tokenAddress: string, amount: number): Promise<GasEstimation> => {\n    try {\n      // Simulate gas estimation (in production, this would call actual RPC)\n      const baseFee = networkStats.baseFee;\n      const priorityFee = Math.max(2, baseFee * 0.1);\n      const maxFeePerGas = baseFee * 2 + priorityFee;\n      const gasLimit = 150000 + Math.floor(Math.random() * 50000);\n      \n      const estimation: GasEstimation = {\n        baseFee,\n        maxFeePerGas,\n        maxPriorityFeePerGas: priorityFee,\n        gasLimit,\n        estimatedCost: (maxFeePerGas * gasLimit) / 1e18,\n        executionTime: networkStats.avgBlockTime + (networkStats.networkCongestion === 'high' ? 20 : \n                       networkStats.networkCongestion === 'medium' ? 10 : 5),\n        confidence: Math.random() * 0.3 + 0.7, // 70-100% confidence\n      };\n\n      setGasEstimations(prev => new Map(prev.set(tokenAddress, estimation)));\n      return estimation;\n    } catch (error) {\n      console.error('Gas estimation failed:', error);\n      throw error;\n    }\n  }, [networkStats]);\n\n  /**\n   * Smart slippage adjustment based on liquidity and volatility\n   */\n  const calculateSmartSlippage = useCallback((\n    tokenAddress: string,\n    baseSlippage: number,\n    maxSlippage: number,\n    liquidityThreshold: number,\n    volatilityMultiplier: number\n  ): SlippageCalculation => {\n    // Simulate market conditions\n    const liquidity = Math.random() * 5000000 + 100000; // $100K - $5M\n    const volatility = Math.random() * 50 + 5; // 5% - 55%\n    const volume24h = Math.random() * 1000000 + 10000; // $10K - $1M\n\n    // Calculate adjustment factors\n    const liquidityFactor = Math.max(0.5, Math.min(2, liquidityThreshold / liquidity));\n    const volatilityFactor = Math.max(0.5, Math.min(3, volatility / 20));\n    const volumeFactor = Math.max(0.8, Math.min(1.5, volume24h / 500000));\n\n    // Calculate adjusted slippage\n    const adjustedSlippage = baseSlippage * liquidityFactor * volatilityFactor * volumeFactor * volatilityMultiplier;\n    const recommendedSlippage = Math.min(maxSlippage, Math.max(baseSlippage * 0.5, adjustedSlippage));\n\n    const calculation: SlippageCalculation = {\n      baseSlippage,\n      adjustedSlippage,\n      liquidityFactor,\n      volatilityFactor,\n      recommendedSlippage,\n      confidence: Math.random() * 0.4 + 0.6, // 60-100% confidence\n    };\n\n    setSlippageCalculations(prev => new Map(prev.set(tokenAddress, calculation)));\n    return calculation;\n  }, []);\n\n  /**\n   * Advanced stop-loss and take-profit logic\n   */\n  const calculateExitStrategy = useCallback((\n    buyPrice: number,\n    currentPrice: number,\n    config: SnipeConfig\n  ) => {\n    if (!config.autoSell?.enabled) return null;\n\n    const priceChange = ((currentPrice - buyPrice) / buyPrice) * 100;\n    const { profitTarget, stopLoss, trailingStop, partialSelling } = config.autoSell;\n\n    const strategy = {\n      shouldSell: false,\n      sellPercentage: 100,\n      reason: '',\n      urgency: 'normal' as 'low' | 'normal' | 'high',\n    };\n\n    // Check stop-loss\n    if (priceChange <= stopLoss) {\n      strategy.shouldSell = true;\n      strategy.reason = `Stop-loss triggered at ${priceChange.toFixed(2)}%`;\n      strategy.urgency = 'high';\n      return strategy;\n    }\n\n    // Check take-profit\n    if (priceChange >= profitTarget) {\n      strategy.shouldSell = true;\n      strategy.reason = `Take-profit triggered at ${priceChange.toFixed(2)}%`;\n      strategy.urgency = 'normal';\n      return strategy;\n    }\n\n    // Check partial selling\n    if (partialSelling.enabled && partialSelling.priceTargets.length > 0) {\n      for (let i = 0; i < partialSelling.priceTargets.length; i++) {\n        const target = partialSelling.priceTargets[i];\n        const percentage = partialSelling.percentages[i] || 25;\n        \n        if (priceChange >= target) {\n          strategy.shouldSell = true;\n          strategy.sellPercentage = percentage;\n          strategy.reason = `Partial sell ${percentage}% at ${priceChange.toFixed(2)}%`;\n          strategy.urgency = 'low';\n          break;\n        }\n      }\n    }\n\n    // Check trailing stop\n    if (trailingStop.enabled && priceChange >= trailingStop.activationPrice) {\n      // This would need to track the highest price reached\n      // For now, simplified logic\n      const trailingStopPrice = currentPrice * (1 - trailingStop.percentage / 100);\n      if (currentPrice <= trailingStopPrice) {\n        strategy.shouldSell = true;\n        strategy.reason = `Trailing stop triggered at ${priceChange.toFixed(2)}%`;\n        strategy.urgency = 'high';\n      }\n    }\n\n    return strategy;\n  }, []);\n\n  /**\n   * Transaction queue management with nonce handling\n   */\n  const addToQueue = useCallback((\n    snipeConfigId: string,\n    type: 'buy' | 'sell',\n    priority: number,\n    gasSettings: GasEstimation\n  ) => {\n    const queueItem: TransactionQueueItem = {\n      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      snipeConfigId,\n      type,\n      priority,\n      nonce: nonceRef.current++,\n      gasSettings,\n      status: 'queued',\n      createdAt: Date.now(),\n      retryCount: 0,\n    };\n\n    setTransactionQueue(prev => {\n      const newQueue = [...prev, queueItem];\n      // Sort by priority (higher first), then by creation time\n      return newQueue.sort((a, b) => {\n        if (a.priority !== b.priority) return b.priority - a.priority;\n        return a.createdAt - b.createdAt;\n      });\n    });\n\n    return queueItem.id;\n  }, []);\n\n  /**\n   * Process transaction queue with batch support\n   */\n  const processQueue = useCallback(async () => {\n    if (processingQueue.current) return;\n    processingQueue.current = true;\n\n    try {\n      const queuedItems = transactionQueue.filter(item => item.status === 'queued');\n      if (queuedItems.length === 0) return;\n\n      // Process in batches\n      const batchSize = 3; // Configurable batch size\n      const batch = queuedItems.slice(0, batchSize);\n\n      for (const item of batch) {\n        setTransactionQueue(prev => \n          prev.map(qi => \n            qi.id === item.id ? { ...qi, status: 'processing', executedAt: Date.now() } : qi\n          )\n        );\n\n        try {\n          // Simulate transaction execution\n          await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n          \n          // Simulate success/failure\n          const success = Math.random() > 0.1; // 90% success rate\n          \n          setTransactionQueue(prev => \n            prev.map(qi => \n              qi.id === item.id ? { \n                ...qi, \n                status: success ? 'confirmed' : 'failed',\n                retryCount: success ? qi.retryCount : qi.retryCount + 1\n              } : qi\n            )\n          );\n\n          // If failed and under retry limit, requeue\n          if (!success && item.retryCount < 3) {\n            setTimeout(() => {\n              setTransactionQueue(prev => \n                prev.map(qi => \n                  qi.id === item.id ? { ...qi, status: 'queued' } : qi\n                )\n              );\n            }, 5000); // Retry after 5 seconds\n          }\n\n        } catch (error) {\n          console.error('Transaction execution failed:', error);\n          setTransactionQueue(prev => \n            prev.map(qi => \n              qi.id === item.id ? { ...qi, status: 'failed', retryCount: qi.retryCount + 1 } : qi\n            )\n          );\n        }\n\n        // Delay between batch transactions\n        if (batch.indexOf(item) < batch.length - 1) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n        }\n      }\n    } finally {\n      processingQueue.current = false;\n    }\n  }, [transactionQueue]);\n\n  /**\n   * Update network statistics\n   */\n  const updateNetworkStats = useCallback(() => {\n    setNetworkStats(prev => ({\n      baseFee: prev.baseFee + (Math.random() - 0.5) * 5,\n      fastGasPrice: prev.fastGasPrice + (Math.random() - 0.5) * 8,\n      networkCongestion: (['low', 'medium', 'high'][Math.floor(Math.random() * 3)] as 'low' | 'medium' | 'high'),\n      avgBlockTime: 12 + (Math.random() - 0.5) * 4,\n    }));\n  }, []);\n\n  // Auto-process queue\n  useEffect(() => {\n    const interval = setInterval(processQueue, 2000);\n    return () => clearInterval(interval);\n  }, [processQueue]);\n\n  // Update network stats periodically\n  useEffect(() => {\n    const interval = setInterval(updateNetworkStats, 10000);\n    return () => clearInterval(interval);\n  }, [updateNetworkStats]);\n\n  // Clean up old transactions\n  useEffect(() => {\n    const cleanup = setInterval(() => {\n      setTransactionQueue(prev => \n        prev.filter(item => Date.now() - item.createdAt < 300000) // Keep last 5 minutes\n      );\n    }, 30000);\n\n    return () => clearInterval(cleanup);\n  }, []);\n\n  return {\n    gasEstimations,\n    transactionQueue,\n    slippageCalculations,\n    networkStats,\n    estimateGas,\n    calculateSmartSlippage,\n    calculateExitStrategy,\n    addToQueue,\n    processQueue,\n    updateNetworkStats,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}