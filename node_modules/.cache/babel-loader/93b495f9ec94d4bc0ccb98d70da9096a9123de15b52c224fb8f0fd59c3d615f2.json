{"ast":null,"code":"/**\n * Transaction storage service for managing user trade history\n *//**\n * Transaction Storage Service\n */export class TransactionStorageService{constructor(){this.STORAGE_KEY_PREFIX='cryptosniper_transactions_';this.STORAGE_META_KEY='cryptosniper_tx_meta_';this.MAX_TRANSACTIONS_PER_PAGE=25;this.MIN_DASHBOARD_DISPLAY=10;this.MAX_RAM_TRANSACTIONS=100;}// Keep max 100 in memory\n/**\n   * Save transaction to user's history\n   */saveTransaction(userId,transaction){try{const meta=this.getTransactionMeta(userId);const currentPage=Math.floor(meta.totalTransactions/this.MAX_TRANSACTIONS_PER_PAGE);// Get current page transactions\nconst pageTransactions=this.getTransactionPage(userId,currentPage);// Add new transaction at the beginning\npageTransactions.unshift(transaction);// If page is full, move oldest to next page\nif(pageTransactions.length>this.MAX_TRANSACTIONS_PER_PAGE){const overflow=pageTransactions.splice(this.MAX_TRANSACTIONS_PER_PAGE);this.saveTransactionPage(userId,currentPage+1,overflow);}// Save current page\nthis.saveTransactionPage(userId,currentPage,pageTransactions);// Update metadata\nmeta.totalTransactions++;meta.totalPages=Math.ceil(meta.totalTransactions/this.MAX_TRANSACTIONS_PER_PAGE);meta.lastUpdated=Date.now();this.saveTransactionMeta(userId,meta);console.log(`ðŸ’¾ Transaction saved for user ${userId}`);}catch(error){console.error('Error saving transaction:',error);}}/**\n   * Get transactions for dashboard display (most recent, limited)\n   */getDashboardTransactions(userId){try{const meta=this.getTransactionMeta(userId);if(meta.totalTransactions===0)return[];// Get first page (most recent)\nconst firstPage=this.getTransactionPage(userId,0);// Return minimum display amount or less\nreturn firstPage.slice(0,this.MIN_DASHBOARD_DISPLAY);}catch(error){console.error('Error loading dashboard transactions:',error);return[];}}/**\n   * Get paginated transaction history\n   */getTransactionHistory(userId){let page=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;try{const meta=this.getTransactionMeta(userId);const transactions=this.getTransactionPage(userId,page);return{transactions,page,totalPages:meta.totalPages,totalTransactions:meta.totalTransactions};}catch(error){console.error('Error loading transaction history:',error);return{transactions:[],page:0,totalPages:0,totalTransactions:0};}}/**\n   * Get user transaction statistics\n   */getTransactionStats(userId){try{const meta=this.getTransactionMeta(userId);const recentTransactions=this.getDashboardTransactions(userId);const successful=recentTransactions.filter(tx=>tx.status==='success').length;const failed=recentTransactions.filter(tx=>tx.status==='failed').length;const pending=recentTransactions.filter(tx=>tx.status==='pending').length;const totalProfit=recentTransactions.filter(tx=>tx.profit!==undefined).reduce((sum,tx)=>sum+(tx.profit||0),0);const completedTransactions=successful+failed;const successRate=completedTransactions>0?successful/completedTransactions*100:0;return{total:meta.totalTransactions,successful,failed,pending,totalProfit,successRate};}catch(error){console.error('Error calculating transaction stats:',error);return{total:0,successful:0,failed:0,pending:0,totalProfit:0,successRate:0};}}/**\n   * Clear old transactions to manage memory\n   */cleanupOldTransactions(userId){try{const meta=this.getTransactionMeta(userId);// If total transactions exceed RAM limit, remove oldest pages\nif(meta.totalTransactions>this.MAX_RAM_TRANSACTIONS){const pagesToKeep=Math.ceil(this.MAX_RAM_TRANSACTIONS/this.MAX_TRANSACTIONS_PER_PAGE);const pagesToDelete=meta.totalPages-pagesToKeep;// Remove oldest pages\nfor(let page=meta.totalPages-1;page>=pagesToKeep;page--){localStorage.removeItem(`${this.STORAGE_KEY_PREFIX}${userId}_page_${page}`);}// Update metadata\nmeta.totalPages=pagesToKeep;meta.totalTransactions=this.MAX_RAM_TRANSACTIONS;this.saveTransactionMeta(userId,meta);console.log(`ðŸ§¹ Cleaned up ${pagesToDelete} transaction pages for user ${userId}`);}}catch(error){console.error('Error cleaning up transactions:',error);}}/**\n   * Export transaction history for user\n   */exportTransactionHistory(userId){try{const meta=this.getTransactionMeta(userId);const allTransactions=[];// Collect all transactions from all pages\nfor(let page=0;page<meta.totalPages;page++){const pageTransactions=this.getTransactionPage(userId,page);allTransactions.push(...pageTransactions);}return JSON.stringify({userId,exportDate:new Date().toISOString(),totalTransactions:allTransactions.length,transactions:allTransactions},null,2);}catch(error){console.error('Error exporting transaction history:',error);return'{}';}}// Private helper methods\ngetStorageKey(userId,page){return`${this.STORAGE_KEY_PREFIX}${userId}_page_${page}`;}getMetaKey(userId){return`${this.STORAGE_META_KEY}${userId}`;}getTransactionPage(userId,page){try{const key=this.getStorageKey(userId,page);const data=localStorage.getItem(key);return data?JSON.parse(data):[];}catch(error){return[];}}saveTransactionPage(userId,page,transactions){const key=this.getStorageKey(userId,page);localStorage.setItem(key,JSON.stringify(transactions));}getTransactionMeta(userId){try{const key=this.getMetaKey(userId);const data=localStorage.getItem(key);return data?JSON.parse(data):{totalTransactions:0,totalPages:0,lastUpdated:Date.now()};}catch(error){return{totalTransactions:0,totalPages:0,lastUpdated:Date.now()};}}saveTransactionMeta(userId,meta){const key=this.getMetaKey(userId);localStorage.setItem(key,JSON.stringify(meta));}}/**\n * Singleton instance\n */export const transactionStorage=new TransactionStorageService();","map":{"version":3,"names":["TransactionStorageService","constructor","STORAGE_KEY_PREFIX","STORAGE_META_KEY","MAX_TRANSACTIONS_PER_PAGE","MIN_DASHBOARD_DISPLAY","MAX_RAM_TRANSACTIONS","saveTransaction","userId","transaction","meta","getTransactionMeta","currentPage","Math","floor","totalTransactions","pageTransactions","getTransactionPage","unshift","length","overflow","splice","saveTransactionPage","totalPages","ceil","lastUpdated","Date","now","saveTransactionMeta","console","log","error","getDashboardTransactions","firstPage","slice","getTransactionHistory","page","arguments","undefined","transactions","getTransactionStats","recentTransactions","successful","filter","tx","status","failed","pending","totalProfit","profit","reduce","sum","completedTransactions","successRate","total","cleanupOldTransactions","pagesToKeep","pagesToDelete","localStorage","removeItem","exportTransactionHistory","allTransactions","push","JSON","stringify","exportDate","toISOString","getStorageKey","getMetaKey","key","data","getItem","parse","setItem","transactionStorage"],"sources":["C:/Users/tpars/source/repos/Crypto Sniper Pro_ AI-Powered Ethereum Trading App/src/services/transactionStorage.ts"],"sourcesContent":["/**\n * Transaction storage service for managing user trade history\n */\n\nimport { Transaction } from '../types/trading';\n\ninterface TransactionPage {\n  transactions: Transaction[];\n  page: number;\n  totalPages: number;\n  totalTransactions: number;\n}\n\n/**\n * Transaction Storage Service\n */\nexport class TransactionStorageService {\n  private readonly STORAGE_KEY_PREFIX = 'cryptosniper_transactions_';\n  private readonly STORAGE_META_KEY = 'cryptosniper_tx_meta_';\n  private readonly MAX_TRANSACTIONS_PER_PAGE = 25;\n  private readonly MIN_DASHBOARD_DISPLAY = 10;\n  private readonly MAX_RAM_TRANSACTIONS = 100; // Keep max 100 in memory\n\n  /**\n   * Save transaction to user's history\n   */\n  saveTransaction(userId: string, transaction: Transaction): void {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const currentPage = Math.floor(meta.totalTransactions / this.MAX_TRANSACTIONS_PER_PAGE);\n      \n      // Get current page transactions\n      const pageTransactions = this.getTransactionPage(userId, currentPage);\n      \n      // Add new transaction at the beginning\n      pageTransactions.unshift(transaction);\n      \n      // If page is full, move oldest to next page\n      if (pageTransactions.length > this.MAX_TRANSACTIONS_PER_PAGE) {\n        const overflow = pageTransactions.splice(this.MAX_TRANSACTIONS_PER_PAGE);\n        this.saveTransactionPage(userId, currentPage + 1, overflow);\n      }\n      \n      // Save current page\n      this.saveTransactionPage(userId, currentPage, pageTransactions);\n      \n      // Update metadata\n      meta.totalTransactions++;\n      meta.totalPages = Math.ceil(meta.totalTransactions / this.MAX_TRANSACTIONS_PER_PAGE);\n      meta.lastUpdated = Date.now();\n      \n      this.saveTransactionMeta(userId, meta);\n      \n      console.log(`ðŸ’¾ Transaction saved for user ${userId}`);\n    } catch (error) {\n      console.error('Error saving transaction:', error);\n    }\n  }\n\n  /**\n   * Get transactions for dashboard display (most recent, limited)\n   */\n  getDashboardTransactions(userId: string): Transaction[] {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      if (meta.totalTransactions === 0) return [];\n      \n      // Get first page (most recent)\n      const firstPage = this.getTransactionPage(userId, 0);\n      \n      // Return minimum display amount or less\n      return firstPage.slice(0, this.MIN_DASHBOARD_DISPLAY);\n    } catch (error) {\n      console.error('Error loading dashboard transactions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get paginated transaction history\n   */\n  getTransactionHistory(userId: string, page: number = 0): TransactionPage {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const transactions = this.getTransactionPage(userId, page);\n      \n      return {\n        transactions,\n        page,\n        totalPages: meta.totalPages,\n        totalTransactions: meta.totalTransactions\n      };\n    } catch (error) {\n      console.error('Error loading transaction history:', error);\n      return {\n        transactions: [],\n        page: 0,\n        totalPages: 0,\n        totalTransactions: 0\n      };\n    }\n  }\n\n  /**\n   * Get user transaction statistics\n   */\n  getTransactionStats(userId: string): {\n    total: number;\n    successful: number;\n    failed: number;\n    pending: number;\n    totalProfit: number;\n    successRate: number;\n  } {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const recentTransactions = this.getDashboardTransactions(userId);\n      \n      const successful = recentTransactions.filter(tx => tx.status === 'success').length;\n      const failed = recentTransactions.filter(tx => tx.status === 'failed').length;\n      const pending = recentTransactions.filter(tx => tx.status === 'pending').length;\n      \n      const totalProfit = recentTransactions\n        .filter(tx => tx.profit !== undefined)\n        .reduce((sum, tx) => sum + (tx.profit || 0), 0);\n      \n      const completedTransactions = successful + failed;\n      const successRate = completedTransactions > 0 ? (successful / completedTransactions) * 100 : 0;\n      \n      return {\n        total: meta.totalTransactions,\n        successful,\n        failed,\n        pending,\n        totalProfit,\n        successRate\n      };\n    } catch (error) {\n      console.error('Error calculating transaction stats:', error);\n      return {\n        total: 0,\n        successful: 0,\n        failed: 0,\n        pending: 0,\n        totalProfit: 0,\n        successRate: 0\n      };\n    }\n  }\n\n  /**\n   * Clear old transactions to manage memory\n   */\n  cleanupOldTransactions(userId: string): void {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      \n      // If total transactions exceed RAM limit, remove oldest pages\n      if (meta.totalTransactions > this.MAX_RAM_TRANSACTIONS) {\n        const pagesToKeep = Math.ceil(this.MAX_RAM_TRANSACTIONS / this.MAX_TRANSACTIONS_PER_PAGE);\n        const pagesToDelete = meta.totalPages - pagesToKeep;\n        \n        // Remove oldest pages\n        for (let page = meta.totalPages - 1; page >= pagesToKeep; page--) {\n          localStorage.removeItem(`${this.STORAGE_KEY_PREFIX}${userId}_page_${page}`);\n        }\n        \n        // Update metadata\n        meta.totalPages = pagesToKeep;\n        meta.totalTransactions = this.MAX_RAM_TRANSACTIONS;\n        this.saveTransactionMeta(userId, meta);\n        \n        console.log(`ðŸ§¹ Cleaned up ${pagesToDelete} transaction pages for user ${userId}`);\n      }\n    } catch (error) {\n      console.error('Error cleaning up transactions:', error);\n    }\n  }\n\n  /**\n   * Export transaction history for user\n   */\n  exportTransactionHistory(userId: string): string {\n    try {\n      const meta = this.getTransactionMeta(userId);\n      const allTransactions: Transaction[] = [];\n      \n      // Collect all transactions from all pages\n      for (let page = 0; page < meta.totalPages; page++) {\n        const pageTransactions = this.getTransactionPage(userId, page);\n        allTransactions.push(...pageTransactions);\n      }\n      \n      return JSON.stringify({\n        userId,\n        exportDate: new Date().toISOString(),\n        totalTransactions: allTransactions.length,\n        transactions: allTransactions\n      }, null, 2);\n    } catch (error) {\n      console.error('Error exporting transaction history:', error);\n      return '{}';\n    }\n  }\n\n  // Private helper methods\n  private getStorageKey(userId: string, page: number): string {\n    return `${this.STORAGE_KEY_PREFIX}${userId}_page_${page}`;\n  }\n\n  private getMetaKey(userId: string): string {\n    return `${this.STORAGE_META_KEY}${userId}`;\n  }\n\n  private getTransactionPage(userId: string, page: number): Transaction[] {\n    try {\n      const key = this.getStorageKey(userId, page);\n      const data = localStorage.getItem(key);\n      return data ? JSON.parse(data) : [];\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private saveTransactionPage(userId: string, page: number, transactions: Transaction[]): void {\n    const key = this.getStorageKey(userId, page);\n    localStorage.setItem(key, JSON.stringify(transactions));\n  }\n\n  private getTransactionMeta(userId: string): {\n    totalTransactions: number;\n    totalPages: number;\n    lastUpdated: number;\n  } {\n    try {\n      const key = this.getMetaKey(userId);\n      const data = localStorage.getItem(key);\n      return data ? JSON.parse(data) : {\n        totalTransactions: 0,\n        totalPages: 0,\n        lastUpdated: Date.now()\n      };\n    } catch (error) {\n      return {\n        totalTransactions: 0,\n        totalPages: 0,\n        lastUpdated: Date.now()\n      };\n    }\n  }\n\n  private saveTransactionMeta(userId: string, meta: {\n    totalTransactions: number;\n    totalPages: number;\n    lastUpdated: number;\n  }): void {\n    const key = this.getMetaKey(userId);\n    localStorage.setItem(key, JSON.stringify(meta));\n  }\n}\n\n/**\n * Singleton instance\n */\nexport const transactionStorage = new TransactionStorageService();\n"],"mappings":"AAAA;AACA;AACA,GAWA;AACA;AACA,GACA,MAAO,MAAM,CAAAA,yBAA0B,CAAAC,YAAA,OACpBC,kBAAkB,CAAG,4BAA4B,MACjDC,gBAAgB,CAAG,uBAAuB,MAC1CC,yBAAyB,CAAG,EAAE,MAC9BC,qBAAqB,CAAG,EAAE,MAC1BC,oBAAoB,CAAG,GAAG,EAAE;AAE7C;AACF;AACA,KACEC,eAAeA,CAACC,MAAc,CAAEC,WAAwB,CAAQ,CAC9D,GAAI,CACF,KAAM,CAAAC,IAAI,CAAG,IAAI,CAACC,kBAAkB,CAACH,MAAM,CAAC,CAC5C,KAAM,CAAAI,WAAW,CAAGC,IAAI,CAACC,KAAK,CAACJ,IAAI,CAACK,iBAAiB,CAAG,IAAI,CAACX,yBAAyB,CAAC,CAEvF;AACA,KAAM,CAAAY,gBAAgB,CAAG,IAAI,CAACC,kBAAkB,CAACT,MAAM,CAAEI,WAAW,CAAC,CAErE;AACAI,gBAAgB,CAACE,OAAO,CAACT,WAAW,CAAC,CAErC;AACA,GAAIO,gBAAgB,CAACG,MAAM,CAAG,IAAI,CAACf,yBAAyB,CAAE,CAC5D,KAAM,CAAAgB,QAAQ,CAAGJ,gBAAgB,CAACK,MAAM,CAAC,IAAI,CAACjB,yBAAyB,CAAC,CACxE,IAAI,CAACkB,mBAAmB,CAACd,MAAM,CAAEI,WAAW,CAAG,CAAC,CAAEQ,QAAQ,CAAC,CAC7D,CAEA;AACA,IAAI,CAACE,mBAAmB,CAACd,MAAM,CAAEI,WAAW,CAAEI,gBAAgB,CAAC,CAE/D;AACAN,IAAI,CAACK,iBAAiB,EAAE,CACxBL,IAAI,CAACa,UAAU,CAAGV,IAAI,CAACW,IAAI,CAACd,IAAI,CAACK,iBAAiB,CAAG,IAAI,CAACX,yBAAyB,CAAC,CACpFM,IAAI,CAACe,WAAW,CAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAE7B,IAAI,CAACC,mBAAmB,CAACpB,MAAM,CAAEE,IAAI,CAAC,CAEtCmB,OAAO,CAACC,GAAG,CAAC,iCAAiCtB,MAAM,EAAE,CAAC,CACxD,CAAE,MAAOuB,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACnD,CACF,CAEA;AACF;AACA,KACEC,wBAAwBA,CAACxB,MAAc,CAAiB,CACtD,GAAI,CACF,KAAM,CAAAE,IAAI,CAAG,IAAI,CAACC,kBAAkB,CAACH,MAAM,CAAC,CAC5C,GAAIE,IAAI,CAACK,iBAAiB,GAAK,CAAC,CAAE,MAAO,EAAE,CAE3C;AACA,KAAM,CAAAkB,SAAS,CAAG,IAAI,CAAChB,kBAAkB,CAACT,MAAM,CAAE,CAAC,CAAC,CAEpD;AACA,MAAO,CAAAyB,SAAS,CAACC,KAAK,CAAC,CAAC,CAAE,IAAI,CAAC7B,qBAAqB,CAAC,CACvD,CAAE,MAAO0B,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,uCAAuC,CAAEA,KAAK,CAAC,CAC7D,MAAO,EAAE,CACX,CACF,CAEA;AACF;AACA,KACEI,qBAAqBA,CAAC3B,MAAc,CAAqC,IAAnC,CAAA4B,IAAY,CAAAC,SAAA,CAAAlB,MAAA,IAAAkB,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,CAAC,CACpD,GAAI,CACF,KAAM,CAAA3B,IAAI,CAAG,IAAI,CAACC,kBAAkB,CAACH,MAAM,CAAC,CAC5C,KAAM,CAAA+B,YAAY,CAAG,IAAI,CAACtB,kBAAkB,CAACT,MAAM,CAAE4B,IAAI,CAAC,CAE1D,MAAO,CACLG,YAAY,CACZH,IAAI,CACJb,UAAU,CAAEb,IAAI,CAACa,UAAU,CAC3BR,iBAAiB,CAAEL,IAAI,CAACK,iBAC1B,CAAC,CACH,CAAE,MAAOgB,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,oCAAoC,CAAEA,KAAK,CAAC,CAC1D,MAAO,CACLQ,YAAY,CAAE,EAAE,CAChBH,IAAI,CAAE,CAAC,CACPb,UAAU,CAAE,CAAC,CACbR,iBAAiB,CAAE,CACrB,CAAC,CACH,CACF,CAEA;AACF;AACA,KACEyB,mBAAmBA,CAAChC,MAAc,CAOhC,CACA,GAAI,CACF,KAAM,CAAAE,IAAI,CAAG,IAAI,CAACC,kBAAkB,CAACH,MAAM,CAAC,CAC5C,KAAM,CAAAiC,kBAAkB,CAAG,IAAI,CAACT,wBAAwB,CAACxB,MAAM,CAAC,CAEhE,KAAM,CAAAkC,UAAU,CAAGD,kBAAkB,CAACE,MAAM,CAACC,EAAE,EAAIA,EAAE,CAACC,MAAM,GAAK,SAAS,CAAC,CAAC1B,MAAM,CAClF,KAAM,CAAA2B,MAAM,CAAGL,kBAAkB,CAACE,MAAM,CAACC,EAAE,EAAIA,EAAE,CAACC,MAAM,GAAK,QAAQ,CAAC,CAAC1B,MAAM,CAC7E,KAAM,CAAA4B,OAAO,CAAGN,kBAAkB,CAACE,MAAM,CAACC,EAAE,EAAIA,EAAE,CAACC,MAAM,GAAK,SAAS,CAAC,CAAC1B,MAAM,CAE/E,KAAM,CAAA6B,WAAW,CAAGP,kBAAkB,CACnCE,MAAM,CAACC,EAAE,EAAIA,EAAE,CAACK,MAAM,GAAKX,SAAS,CAAC,CACrCY,MAAM,CAAC,CAACC,GAAG,CAAEP,EAAE,GAAKO,GAAG,EAAIP,EAAE,CAACK,MAAM,EAAI,CAAC,CAAC,CAAE,CAAC,CAAC,CAEjD,KAAM,CAAAG,qBAAqB,CAAGV,UAAU,CAAGI,MAAM,CACjD,KAAM,CAAAO,WAAW,CAAGD,qBAAqB,CAAG,CAAC,CAAIV,UAAU,CAAGU,qBAAqB,CAAI,GAAG,CAAG,CAAC,CAE9F,MAAO,CACLE,KAAK,CAAE5C,IAAI,CAACK,iBAAiB,CAC7B2B,UAAU,CACVI,MAAM,CACNC,OAAO,CACPC,WAAW,CACXK,WACF,CAAC,CACH,CAAE,MAAOtB,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,sCAAsC,CAAEA,KAAK,CAAC,CAC5D,MAAO,CACLuB,KAAK,CAAE,CAAC,CACRZ,UAAU,CAAE,CAAC,CACbI,MAAM,CAAE,CAAC,CACTC,OAAO,CAAE,CAAC,CACVC,WAAW,CAAE,CAAC,CACdK,WAAW,CAAE,CACf,CAAC,CACH,CACF,CAEA;AACF;AACA,KACEE,sBAAsBA,CAAC/C,MAAc,CAAQ,CAC3C,GAAI,CACF,KAAM,CAAAE,IAAI,CAAG,IAAI,CAACC,kBAAkB,CAACH,MAAM,CAAC,CAE5C;AACA,GAAIE,IAAI,CAACK,iBAAiB,CAAG,IAAI,CAACT,oBAAoB,CAAE,CACtD,KAAM,CAAAkD,WAAW,CAAG3C,IAAI,CAACW,IAAI,CAAC,IAAI,CAAClB,oBAAoB,CAAG,IAAI,CAACF,yBAAyB,CAAC,CACzF,KAAM,CAAAqD,aAAa,CAAG/C,IAAI,CAACa,UAAU,CAAGiC,WAAW,CAEnD;AACA,IAAK,GAAI,CAAApB,IAAI,CAAG1B,IAAI,CAACa,UAAU,CAAG,CAAC,CAAEa,IAAI,EAAIoB,WAAW,CAAEpB,IAAI,EAAE,CAAE,CAChEsB,YAAY,CAACC,UAAU,CAAC,GAAG,IAAI,CAACzD,kBAAkB,GAAGM,MAAM,SAAS4B,IAAI,EAAE,CAAC,CAC7E,CAEA;AACA1B,IAAI,CAACa,UAAU,CAAGiC,WAAW,CAC7B9C,IAAI,CAACK,iBAAiB,CAAG,IAAI,CAACT,oBAAoB,CAClD,IAAI,CAACsB,mBAAmB,CAACpB,MAAM,CAAEE,IAAI,CAAC,CAEtCmB,OAAO,CAACC,GAAG,CAAC,iBAAiB2B,aAAa,+BAA+BjD,MAAM,EAAE,CAAC,CACpF,CACF,CAAE,MAAOuB,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,iCAAiC,CAAEA,KAAK,CAAC,CACzD,CACF,CAEA;AACF;AACA,KACE6B,wBAAwBA,CAACpD,MAAc,CAAU,CAC/C,GAAI,CACF,KAAM,CAAAE,IAAI,CAAG,IAAI,CAACC,kBAAkB,CAACH,MAAM,CAAC,CAC5C,KAAM,CAAAqD,eAA8B,CAAG,EAAE,CAEzC;AACA,IAAK,GAAI,CAAAzB,IAAI,CAAG,CAAC,CAAEA,IAAI,CAAG1B,IAAI,CAACa,UAAU,CAAEa,IAAI,EAAE,CAAE,CACjD,KAAM,CAAApB,gBAAgB,CAAG,IAAI,CAACC,kBAAkB,CAACT,MAAM,CAAE4B,IAAI,CAAC,CAC9DyB,eAAe,CAACC,IAAI,CAAC,GAAG9C,gBAAgB,CAAC,CAC3C,CAEA,MAAO,CAAA+C,IAAI,CAACC,SAAS,CAAC,CACpBxD,MAAM,CACNyD,UAAU,CAAE,GAAI,CAAAvC,IAAI,CAAC,CAAC,CAACwC,WAAW,CAAC,CAAC,CACpCnD,iBAAiB,CAAE8C,eAAe,CAAC1C,MAAM,CACzCoB,YAAY,CAAEsB,eAChB,CAAC,CAAE,IAAI,CAAE,CAAC,CAAC,CACb,CAAE,MAAO9B,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,sCAAsC,CAAEA,KAAK,CAAC,CAC5D,MAAO,IAAI,CACb,CACF,CAEA;AACQoC,aAAaA,CAAC3D,MAAc,CAAE4B,IAAY,CAAU,CAC1D,MAAO,GAAG,IAAI,CAAClC,kBAAkB,GAAGM,MAAM,SAAS4B,IAAI,EAAE,CAC3D,CAEQgC,UAAUA,CAAC5D,MAAc,CAAU,CACzC,MAAO,GAAG,IAAI,CAACL,gBAAgB,GAAGK,MAAM,EAAE,CAC5C,CAEQS,kBAAkBA,CAACT,MAAc,CAAE4B,IAAY,CAAiB,CACtE,GAAI,CACF,KAAM,CAAAiC,GAAG,CAAG,IAAI,CAACF,aAAa,CAAC3D,MAAM,CAAE4B,IAAI,CAAC,CAC5C,KAAM,CAAAkC,IAAI,CAAGZ,YAAY,CAACa,OAAO,CAACF,GAAG,CAAC,CACtC,MAAO,CAAAC,IAAI,CAAGP,IAAI,CAACS,KAAK,CAACF,IAAI,CAAC,CAAG,EAAE,CACrC,CAAE,MAAOvC,KAAK,CAAE,CACd,MAAO,EAAE,CACX,CACF,CAEQT,mBAAmBA,CAACd,MAAc,CAAE4B,IAAY,CAAEG,YAA2B,CAAQ,CAC3F,KAAM,CAAA8B,GAAG,CAAG,IAAI,CAACF,aAAa,CAAC3D,MAAM,CAAE4B,IAAI,CAAC,CAC5CsB,YAAY,CAACe,OAAO,CAACJ,GAAG,CAAEN,IAAI,CAACC,SAAS,CAACzB,YAAY,CAAC,CAAC,CACzD,CAEQ5B,kBAAkBA,CAACH,MAAc,CAIvC,CACA,GAAI,CACF,KAAM,CAAA6D,GAAG,CAAG,IAAI,CAACD,UAAU,CAAC5D,MAAM,CAAC,CACnC,KAAM,CAAA8D,IAAI,CAAGZ,YAAY,CAACa,OAAO,CAACF,GAAG,CAAC,CACtC,MAAO,CAAAC,IAAI,CAAGP,IAAI,CAACS,KAAK,CAACF,IAAI,CAAC,CAAG,CAC/BvD,iBAAiB,CAAE,CAAC,CACpBQ,UAAU,CAAE,CAAC,CACbE,WAAW,CAAEC,IAAI,CAACC,GAAG,CAAC,CACxB,CAAC,CACH,CAAE,MAAOI,KAAK,CAAE,CACd,MAAO,CACLhB,iBAAiB,CAAE,CAAC,CACpBQ,UAAU,CAAE,CAAC,CACbE,WAAW,CAAEC,IAAI,CAACC,GAAG,CAAC,CACxB,CAAC,CACH,CACF,CAEQC,mBAAmBA,CAACpB,MAAc,CAAEE,IAI3C,CAAQ,CACP,KAAM,CAAA2D,GAAG,CAAG,IAAI,CAACD,UAAU,CAAC5D,MAAM,CAAC,CACnCkD,YAAY,CAACe,OAAO,CAACJ,GAAG,CAAEN,IAAI,CAACC,SAAS,CAACtD,IAAI,CAAC,CAAC,CACjD,CACF,CAEA;AACA;AACA,GACA,MAAO,MAAM,CAAAgE,kBAAkB,CAAG,GAAI,CAAA1E,yBAAyB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}