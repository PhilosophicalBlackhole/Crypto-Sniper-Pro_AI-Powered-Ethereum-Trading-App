{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * Multi-wallet connection hook supporting MetaMask, Coinbase Wallet, and other providers\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nexport function useMultiWallet() {\n  _s();\n  const [walletState, setWalletState] = useState({\n    connectedWallet: null,\n    address: null,\n    balance: '0',\n    chainId: null,\n    isConnecting: false,\n    error: null,\n    availableWallets: []\n  });\n  const [demoMode, setDemoMode] = useState(false);\n  const detectWallets = useCallback(() => {\n    const wallets = [];\n\n    // MetaMask\n    if (window.ethereum && window.ethereum.isMetaMask) {\n      wallets.push({\n        id: 'metamask',\n        name: 'MetaMask',\n        icon: 'ðŸ¦Š',\n        isInstalled: true,\n        isConnected: false,\n        provider: window.ethereum\n      });\n    }\n\n    // Coinbase Wallet\n    if (window.ethereum && window.ethereum.isCoinbaseWallet) {\n      wallets.push({\n        id: 'coinbase',\n        name: 'Coinbase Wallet',\n        icon: 'ðŸŸ¦',\n        isInstalled: true,\n        isConnected: false,\n        provider: window.ethereum\n      });\n    }\n\n    // WalletConnect (if available)\n    if (window.ethereum && window.ethereum.isWalletConnect) {\n      wallets.push({\n        id: 'walletconnect',\n        name: 'WalletConnect',\n        icon: 'ðŸ”—',\n        isInstalled: true,\n        isConnected: false,\n        provider: window.ethereum\n      });\n    }\n\n    // Generic ethereum provider (fallback)\n    if (window.ethereum && wallets.length === 0) {\n      wallets.push({\n        id: 'ethereum',\n        name: 'Web3 Wallet',\n        icon: 'âš¡',\n        isInstalled: true,\n        isConnected: false,\n        provider: window.ethereum\n      });\n    }\n\n    // Demo wallet (always available)\n    wallets.push({\n      id: 'demo',\n      name: 'Demo Mode',\n      icon: 'ðŸŽ­',\n      isInstalled: true,\n      isConnected: false,\n      provider: null\n    });\n    return wallets;\n  }, []);\n  const updateBalance = useCallback(async (address, provider) => {\n    try {\n      if (provider) {\n        const balance = await provider.request({\n          method: 'eth_getBalance',\n          params: [address, 'latest']\n        });\n        const balanceInEth = (parseInt(balance, 16) / 1e18).toFixed(4);\n        setWalletState(prev => ({\n          ...prev,\n          balance: balanceInEth\n        }));\n      }\n    } catch (error) {\n      console.error('Error fetching balance:', error);\n    }\n  }, []);\n  const connectDemoWallet = useCallback(() => {\n    setWalletState(prev => ({\n      ...prev,\n      isConnecting: true,\n      error: null\n    }));\n    setTimeout(() => {\n      setWalletState(prev => ({\n        ...prev,\n        connectedWallet: 'demo',\n        address: '0x742d35Cc6634C0532925a3b8D398aF7f',\n        balance: '2.4567',\n        chainId: 1,\n        isConnecting: false,\n        error: null,\n        availableWallets: prev.availableWallets.map(w => w.id === 'demo' ? {\n          ...w,\n          isConnected: true\n        } : {\n          ...w,\n          isConnected: false\n        })\n      }));\n      setDemoMode(true);\n    }, 1000);\n  }, []);\n  const connectWallet = useCallback(async walletId => {\n    const wallet = walletState.availableWallets.find(w => w.id === walletId);\n    if (!wallet) return;\n    if (walletId === 'demo') {\n      connectDemoWallet();\n      return;\n    }\n    if (!wallet.provider) {\n      setWalletState(prev => ({\n        ...prev,\n        error: `${wallet.name} is not installed or available.`\n      }));\n      return;\n    }\n    setWalletState(prev => ({\n      ...prev,\n      isConnecting: true,\n      error: null\n    }));\n    try {\n      // For multiple providers, we might need to select the specific one\n      let provider = wallet.provider;\n\n      // If there are multiple providers, try to select the right one\n      if (window.ethereum && window.ethereum.providers) {\n        const providers = window.ethereum.providers;\n        if (walletId === 'metamask') {\n          provider = providers.find(p => p.isMetaMask) || provider;\n        } else if (walletId === 'coinbase') {\n          provider = providers.find(p => p.isCoinbaseWallet) || provider;\n        }\n      }\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts'\n      });\n      const chainId = await provider.request({\n        method: 'eth_chainId'\n      });\n      if (accounts.length > 0) {\n        const address = accounts[0];\n        setWalletState(prev => ({\n          ...prev,\n          connectedWallet: walletId,\n          address,\n          chainId: parseInt(chainId, 16),\n          isConnecting: false,\n          availableWallets: prev.availableWallets.map(w => w.id === walletId ? {\n            ...w,\n            isConnected: true\n          } : {\n            ...w,\n            isConnected: false\n          })\n        }));\n        await updateBalance(address, provider);\n        setDemoMode(false);\n      }\n    } catch (error) {\n      setWalletState(prev => ({\n        ...prev,\n        isConnecting: false,\n        error: error.message || `Failed to connect ${wallet.name}`\n      }));\n    }\n  }, [walletState.availableWallets, updateBalance, connectDemoWallet]);\n  const disconnectWallet = useCallback(() => {\n    setWalletState(prev => ({\n      ...prev,\n      connectedWallet: null,\n      address: null,\n      balance: '0',\n      chainId: null,\n      isConnecting: false,\n      error: null,\n      availableWallets: prev.availableWallets.map(w => ({\n        ...w,\n        isConnected: false\n      }))\n    }));\n    setDemoMode(false);\n  }, []);\n  const switchWallet = useCallback(async newWalletId => {\n    if (walletState.connectedWallet === newWalletId) return;\n\n    // Disconnect current wallet first\n    disconnectWallet();\n\n    // Small delay to ensure clean disconnection\n    setTimeout(() => {\n      connectWallet(newWalletId);\n    }, 500);\n  }, [walletState.connectedWallet, disconnectWallet, connectWallet]);\n\n  // Initialize available wallets on mount\n  useEffect(() => {\n    const wallets = detectWallets();\n    setWalletState(prev => ({\n      ...prev,\n      availableWallets: wallets\n    }));\n  }, [detectWallets]);\n\n  // Listen for account changes\n  useEffect(() => {\n    if (window.ethereum && walletState.connectedWallet && walletState.connectedWallet !== 'demo') {\n      const handleAccountsChanged = accounts => {\n        if (accounts.length === 0) {\n          disconnectWallet();\n        } else {\n          setWalletState(prev => ({\n            ...prev,\n            address: accounts[0]\n          }));\n          const wallet = walletState.availableWallets.find(w => w.id === walletState.connectedWallet);\n          if (wallet !== null && wallet !== void 0 && wallet.provider) {\n            updateBalance(accounts[0], wallet.provider);\n          }\n        }\n      };\n      const handleChainChanged = chainId => {\n        setWalletState(prev => ({\n          ...prev,\n          chainId: parseInt(chainId, 16)\n        }));\n      };\n      window.ethereum.on('accountsChanged', handleAccountsChanged);\n      window.ethereum.on('chainChanged', handleChainChanged);\n      return () => {\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        window.ethereum.removeListener('chainChanged', handleChainChanged);\n      };\n    }\n  }, [walletState.connectedWallet, walletState.availableWallets, disconnectWallet, updateBalance]);\n  return {\n    ...walletState,\n    isConnected: !!walletState.connectedWallet,\n    connectWallet,\n    disconnectWallet,\n    switchWallet,\n    updateBalance: () => {\n      if (walletState.address && walletState.connectedWallet !== 'demo') {\n        const wallet = walletState.availableWallets.find(w => w.id === walletState.connectedWallet);\n        if (wallet !== null && wallet !== void 0 && wallet.provider) {\n          updateBalance(walletState.address, wallet.provider);\n        }\n      }\n    },\n    demoMode\n  };\n}\n_s(useMultiWallet, \"BEYMnwcdeWkMjQQfJWnCAdhfDWw=\");","map":{"version":3,"names":["useState","useEffect","useCallback","useMultiWallet","_s","walletState","setWalletState","connectedWallet","address","balance","chainId","isConnecting","error","availableWallets","demoMode","setDemoMode","detectWallets","wallets","window","ethereum","isMetaMask","push","id","name","icon","isInstalled","isConnected","provider","isCoinbaseWallet","isWalletConnect","length","updateBalance","request","method","params","balanceInEth","parseInt","toFixed","prev","console","connectDemoWallet","setTimeout","map","w","connectWallet","walletId","wallet","find","providers","p","accounts","message","disconnectWallet","switchWallet","newWalletId","handleAccountsChanged","handleChainChanged","on","removeListener"],"sources":["C:/Users/tpars/source/repos/Crypto Sniper Pro_ AI-Powered Ethereum Trading App/src/hooks/useMultiWallet.ts"],"sourcesContent":["/**\n * Multi-wallet connection hook supporting MetaMask, Coinbase Wallet, and other providers\n */\n\nimport { useState, useEffect, useCallback } from 'react';\n\nexport interface WalletProvider {\n  id: string;\n  name: string;\n  icon: string;\n  isInstalled: boolean;\n  isConnected: boolean;\n  provider?: any;\n}\n\nexport interface MultiWalletState {\n  connectedWallet: string | null;\n  address: string | null;\n  balance: string;\n  chainId: number | null;\n  isConnecting: boolean;\n  error: string | null;\n  availableWallets: WalletProvider[];\n}\n\nexport function useMultiWallet() {\n  const [walletState, setWalletState] = useState<MultiWalletState>({\n    connectedWallet: null,\n    address: null,\n    balance: '0',\n    chainId: null,\n    isConnecting: false,\n    error: null,\n    availableWallets: [],\n  });\n\n  const [demoMode, setDemoMode] = useState(false);\n\n  const detectWallets = useCallback((): WalletProvider[] => {\n    const wallets: WalletProvider[] = [];\n\n    // MetaMask\n    if (window.ethereum && window.ethereum.isMetaMask) {\n      wallets.push({\n        id: 'metamask',\n        name: 'MetaMask',\n        icon: 'ðŸ¦Š',\n        isInstalled: true,\n        isConnected: false,\n        provider: window.ethereum,\n      });\n    }\n\n    // Coinbase Wallet\n    if (window.ethereum && window.ethereum.isCoinbaseWallet) {\n      wallets.push({\n        id: 'coinbase',\n        name: 'Coinbase Wallet',\n        icon: 'ðŸŸ¦',\n        isInstalled: true,\n        isConnected: false,\n        provider: window.ethereum,\n      });\n    }\n\n    // WalletConnect (if available)\n    if (window.ethereum && window.ethereum.isWalletConnect) {\n      wallets.push({\n        id: 'walletconnect',\n        name: 'WalletConnect',\n        icon: 'ðŸ”—',\n        isInstalled: true,\n        isConnected: false,\n        provider: window.ethereum,\n      });\n    }\n\n    // Generic ethereum provider (fallback)\n    if (window.ethereum && wallets.length === 0) {\n      wallets.push({\n        id: 'ethereum',\n        name: 'Web3 Wallet',\n        icon: 'âš¡',\n        isInstalled: true,\n        isConnected: false,\n        provider: window.ethereum,\n      });\n    }\n\n    // Demo wallet (always available)\n    wallets.push({\n      id: 'demo',\n      name: 'Demo Mode',\n      icon: 'ðŸŽ­',\n      isInstalled: true,\n      isConnected: false,\n      provider: null,\n    });\n\n    return wallets;\n  }, []);\n\n  const updateBalance = useCallback(async (address: string, provider: any) => {\n    try {\n      if (provider) {\n        const balance = await provider.request({\n          method: 'eth_getBalance',\n          params: [address, 'latest'],\n        });\n        const balanceInEth = (parseInt(balance, 16) / 1e18).toFixed(4);\n        setWalletState(prev => ({ ...prev, balance: balanceInEth }));\n      }\n    } catch (error) {\n      console.error('Error fetching balance:', error);\n    }\n  }, []);\n\n  const connectDemoWallet = useCallback(() => {\n    setWalletState(prev => ({ ...prev, isConnecting: true, error: null }));\n    \n    setTimeout(() => {\n      setWalletState(prev => ({\n        ...prev,\n        connectedWallet: 'demo',\n        address: '0x742d35Cc6634C0532925a3b8D398aF7f',\n        balance: '2.4567',\n        chainId: 1,\n        isConnecting: false,\n        error: null,\n        availableWallets: prev.availableWallets.map(w => \n          w.id === 'demo' ? { ...w, isConnected: true } : { ...w, isConnected: false }\n        ),\n      }));\n      setDemoMode(true);\n    }, 1000);\n  }, []);\n\n  const connectWallet = useCallback(async (walletId: string) => {\n    const wallet = walletState.availableWallets.find(w => w.id === walletId);\n    if (!wallet) return;\n\n    if (walletId === 'demo') {\n      connectDemoWallet();\n      return;\n    }\n\n    if (!wallet.provider) {\n      setWalletState(prev => ({\n        ...prev,\n        error: `${wallet.name} is not installed or available.`,\n      }));\n      return;\n    }\n\n    setWalletState(prev => ({ ...prev, isConnecting: true, error: null }));\n\n    try {\n      // For multiple providers, we might need to select the specific one\n      let provider = wallet.provider;\n      \n      // If there are multiple providers, try to select the right one\n      if (window.ethereum && window.ethereum.providers) {\n        const providers = window.ethereum.providers;\n        if (walletId === 'metamask') {\n          provider = providers.find((p: any) => p.isMetaMask) || provider;\n        } else if (walletId === 'coinbase') {\n          provider = providers.find((p: any) => p.isCoinbaseWallet) || provider;\n        }\n      }\n\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts',\n      });\n\n      const chainId = await provider.request({\n        method: 'eth_chainId',\n      });\n\n      if (accounts.length > 0) {\n        const address = accounts[0];\n        setWalletState(prev => ({\n          ...prev,\n          connectedWallet: walletId,\n          address,\n          chainId: parseInt(chainId, 16),\n          isConnecting: false,\n          availableWallets: prev.availableWallets.map(w => \n            w.id === walletId ? { ...w, isConnected: true } : { ...w, isConnected: false }\n          ),\n        }));\n        await updateBalance(address, provider);\n        setDemoMode(false);\n      }\n    } catch (error: any) {\n      setWalletState(prev => ({\n        ...prev,\n        isConnecting: false,\n        error: error.message || `Failed to connect ${wallet.name}`,\n      }));\n    }\n  }, [walletState.availableWallets, updateBalance, connectDemoWallet]);\n\n  const disconnectWallet = useCallback(() => {\n    setWalletState(prev => ({\n      ...prev,\n      connectedWallet: null,\n      address: null,\n      balance: '0',\n      chainId: null,\n      isConnecting: false,\n      error: null,\n      availableWallets: prev.availableWallets.map(w => ({ ...w, isConnected: false })),\n    }));\n    setDemoMode(false);\n  }, []);\n\n  const switchWallet = useCallback(async (newWalletId: string) => {\n    if (walletState.connectedWallet === newWalletId) return;\n    \n    // Disconnect current wallet first\n    disconnectWallet();\n    \n    // Small delay to ensure clean disconnection\n    setTimeout(() => {\n      connectWallet(newWalletId);\n    }, 500);\n  }, [walletState.connectedWallet, disconnectWallet, connectWallet]);\n\n  // Initialize available wallets on mount\n  useEffect(() => {\n    const wallets = detectWallets();\n    setWalletState(prev => ({ ...prev, availableWallets: wallets }));\n  }, [detectWallets]);\n\n  // Listen for account changes\n  useEffect(() => {\n    if (window.ethereum && walletState.connectedWallet && walletState.connectedWallet !== 'demo') {\n      const handleAccountsChanged = (accounts: string[]) => {\n        if (accounts.length === 0) {\n          disconnectWallet();\n        } else {\n          setWalletState(prev => ({ ...prev, address: accounts[0] }));\n          const wallet = walletState.availableWallets.find(w => w.id === walletState.connectedWallet);\n          if (wallet?.provider) {\n            updateBalance(accounts[0], wallet.provider);\n          }\n        }\n      };\n\n      const handleChainChanged = (chainId: string) => {\n        setWalletState(prev => ({ \n          ...prev, \n          chainId: parseInt(chainId, 16) \n        }));\n      };\n\n      window.ethereum.on('accountsChanged', handleAccountsChanged);\n      window.ethereum.on('chainChanged', handleChainChanged);\n\n      return () => {\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        window.ethereum.removeListener('chainChanged', handleChainChanged);\n      };\n    }\n  }, [walletState.connectedWallet, walletState.availableWallets, disconnectWallet, updateBalance]);\n\n  return {\n    ...walletState,\n    isConnected: !!walletState.connectedWallet,\n    connectWallet,\n    disconnectWallet,\n    switchWallet,\n    updateBalance: () => {\n      if (walletState.address && walletState.connectedWallet !== 'demo') {\n        const wallet = walletState.availableWallets.find(w => w.id === walletState.connectedWallet);\n        if (wallet?.provider) {\n          updateBalance(walletState.address, wallet.provider);\n        }\n      }\n    },\n    demoMode,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}