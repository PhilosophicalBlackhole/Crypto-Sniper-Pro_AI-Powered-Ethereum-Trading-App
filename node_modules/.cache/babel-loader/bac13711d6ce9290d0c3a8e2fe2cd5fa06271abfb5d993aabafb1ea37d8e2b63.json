{"ast":null,"code":"/**\n * Real trading service for premium users with mainnet connectivity\n */\n\n// Note: ethers import removed to prevent process.env errors\n// Will implement without ethers dependency for now\n\nclass RealTradingService {\n  constructor() {\n    this.provider = null;\n    this.signer = null;\n    this.isMainnet = false;\n    // Uniswap V2 Router address on Ethereum mainnet\n    this.UNISWAP_V2_ROUTER = '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D';\n    // WETH address on Ethereum mainnet\n    this.WETH_ADDRESS = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\n  }\n  /**\n   * Initialize real trading connection\n   */\n  async initialize(forceMainnet = false) {\n    try {\n      if (!window.ethereum) {\n        throw new Error('MetaMask not found');\n      }\n\n      // Using native Web3 provider instead of ethers to avoid process.env errors\n      this.provider = window.ethereum;\n      this.signer = window.ethereum;\n\n      // Check network using native provider\n      const chainId = await this.provider.request({\n        method: 'eth_chainId'\n      });\n      this.isMainnet = parseInt(chainId, 16) === 1;\n      if (forceMainnet && !this.isMainnet) {\n        // Switch to mainnet\n        await this.switchToMainnet();\n      }\n      console.log(`Connected to ${this.isMainnet ? 'Mainnet' : 'Testnet'} (Chain ID: ${parseInt(chainId, 16)})`);\n      return true;\n    } catch (error) {\n      console.error('Failed to initialize real trading:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Switch to Ethereum mainnet\n   */\n  async switchToMainnet() {\n    try {\n      await window.ethereum.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: '0x1'\n        }] // Ethereum mainnet\n      });\n\n      // Wait for network switch\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Reinitialize provider after network switch\n      this.provider = window.ethereum;\n      this.signer = window.ethereum;\n      this.isMainnet = true;\n    } catch (error) {\n      console.error('Failed to switch to mainnet:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get token information from blockchain\n   */\n  async getTokenInfo(tokenAddress) {\n    try {\n      if (!this.provider) throw new Error('Provider not initialized');\n\n      // For now, return mock data to avoid ethers dependency\n      // In production, would implement with native Web3 calls\n      const mockTokenInfo = {\n        address: tokenAddress,\n        symbol: 'TOKEN',\n        name: 'Demo Token',\n        decimals: 18,\n        totalSupply: '1000000000000000000000000',\n        // 1M tokens\n        liquidity_usd: Math.random() * 100000\n      };\n      return mockTokenInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get token liquidity from Uniswap\n   */\n  async getTokenLiquidity(tokenAddress) {\n    try {\n      // This would call Uniswap subgraph or API\n      // For now, return a mock value\n      return Math.random() * 100000; // Random liquidity between 0-100k\n    } catch (error) {\n      console.error('Error getting token liquidity:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Execute real buy transaction\n   */\n  async buyToken(tokenAddress, amountETH, config) {\n    try {\n      if (!this.provider || !this.signer) {\n        throw new Error('Trading service not initialized');\n      }\n      if (!this.isMainnet) {\n        throw new Error('Real trading only available on mainnet');\n      }\n\n      // For now, simulate the transaction to avoid ethers dependency\n      // In production, would implement with native Web3 calls\n      console.log(`Simulating buy of ${amountETH} ETH worth of ${tokenAddress}`);\n\n      // Simulate transaction hash\n      const mockTxHash = `0x${Math.random().toString(16).substring(2)}${Date.now().toString(16)}`;\n      return {\n        success: true,\n        txHash: mockTxHash,\n        gasUsed: 21000,\n        actualPrice: amountETH * 1000,\n        // Mock price\n        slippage: config.slippageTolerance * 0.5\n      };\n    } catch (error) {\n      console.error('Error executing buy transaction:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Transaction failed'\n      };\n    }\n  }\n\n  /**\n   * Execute real sell transaction\n   */\n  async sellToken(tokenAddress, tokenAmount, config) {\n    try {\n      if (!this.provider || !this.signer) {\n        throw new Error('Trading service not initialized');\n      }\n\n      // Similar to buyToken but for selling\n      // Would implement token approval and swap logic\n\n      return {\n        success: false,\n        error: 'Sell functionality not yet implemented'\n      };\n    } catch (error) {\n      console.error('Error executing sell transaction:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Transaction failed'\n      };\n    }\n  }\n\n  /**\n   * Get user's ETH balance\n   */\n  async getETHBalance() {\n    try {\n      if (!this.provider) return 0;\n      const accounts = await this.provider.request({\n        method: 'eth_accounts'\n      });\n      if (accounts.length === 0) return 0;\n      const balance = await this.provider.request({\n        method: 'eth_getBalance',\n        params: [accounts[0], 'latest']\n      });\n\n      // Convert hex to decimal and then to ETH (divide by 10^18)\n      const balanceInWei = parseInt(balance, 16);\n      return balanceInWei / Math.pow(10, 18);\n    } catch (error) {\n      console.error('Error getting ETH balance:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get user's token balance\n   */\n  async getTokenBalance(tokenAddress) {\n    try {\n      if (!this.provider) return 0;\n\n      // For now, return mock balance to avoid ethers dependency\n      // In production, would implement with native Web3 contract calls\n      return Math.random() * 1000; // Random balance between 0-1000 tokens\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Check if connected to mainnet\n   */\n  isConnectedToMainnet() {\n    return this.isMainnet;\n  }\n\n  /**\n   * Get current network info\n   */\n  async getNetworkInfo() {\n    if (!this.provider) {\n      return {\n        chainId: 0,\n        name: 'Not connected',\n        isMainnet: false\n      };\n    }\n    try {\n      const chainId = await this.provider.request({\n        method: 'eth_chainId'\n      });\n      const chainIdNum = parseInt(chainId, 16);\n      const networkNames = {\n        1: 'Ethereum Mainnet',\n        5: 'Goerli Testnet',\n        11155111: 'Sepolia Testnet',\n        137: 'Polygon',\n        56: 'BSC'\n      };\n      return {\n        chainId: chainIdNum,\n        name: networkNames[chainIdNum] || `Chain ${chainIdNum}`,\n        isMainnet: chainIdNum === 1\n      };\n    } catch (error) {\n      console.error('Error getting network info:', error);\n      return {\n        chainId: 0,\n        name: 'Unknown',\n        isMainnet: false\n      };\n    }\n  }\n}\nexport const realTradingService = new RealTradingService();\nexport default realTradingService;","map":{"version":3,"names":["RealTradingService","constructor","provider","signer","isMainnet","UNISWAP_V2_ROUTER","WETH_ADDRESS","initialize","forceMainnet","window","ethereum","Error","chainId","request","method","parseInt","switchToMainnet","console","log","error","params","Promise","resolve","setTimeout","getTokenInfo","tokenAddress","mockTokenInfo","address","symbol","name","decimals","totalSupply","liquidity_usd","Math","random","getTokenLiquidity","buyToken","amountETH","config","mockTxHash","toString","substring","Date","now","success","txHash","gasUsed","actualPrice","slippage","slippageTolerance","message","sellToken","tokenAmount","getETHBalance","accounts","length","balance","balanceInWei","pow","getTokenBalance","isConnectedToMainnet","getNetworkInfo","chainIdNum","networkNames","realTradingService"],"sources":["C:/Users/tpars/source/repos/Crypto Sniper Pro_ AI-Powered Ethereum Trading App/src/services/realTradingService.ts"],"sourcesContent":["/**\n * Real trading service for premium users with mainnet connectivity\n */\n\n// Note: ethers import removed to prevent process.env errors\n// Will implement without ethers dependency for now\n\nexport interface TradingConfig {\n  slippageTolerance: number; // Percentage (e.g., 1 for 1%)\n  gasMultiplier: number; // Multiplier for gas price (e.g., 1.5 for 50% higher)\n  mevProtection: boolean;\n  maxGasPrice: number; // Max gas price in GWEI\n  minLiquidity: number; // Minimum liquidity in USD\n}\n\nexport interface TokenInfo {\n  address: string;\n  symbol: string;\n  name: string;\n  decimals: number;\n  totalSupply?: string;\n  holder_count?: number;\n  liquidity_usd?: number;\n}\n\nexport interface TradingResult {\n  success: boolean;\n  txHash?: string;\n  error?: string;\n  gasUsed?: number;\n  actualPrice?: number;\n  slippage?: number;\n}\n\nclass RealTradingService {\n  private provider: any = null;\n  private signer: any = null;\n  private isMainnet = false;\n\n  // Uniswap V2 Router address on Ethereum mainnet\n  private readonly UNISWAP_V2_ROUTER = '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D';\n  \n  // WETH address on Ethereum mainnet\n  private readonly WETH_ADDRESS = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\n\n  /**\n   * Initialize real trading connection\n   */\n  async initialize(forceMainnet = false): Promise<boolean> {\n    try {\n      if (!window.ethereum) {\n        throw new Error('MetaMask not found');\n      }\n\n      // Using native Web3 provider instead of ethers to avoid process.env errors\n      this.provider = window.ethereum;\n      this.signer = window.ethereum;\n\n      // Check network using native provider\n      const chainId = await this.provider.request({ method: 'eth_chainId' });\n      this.isMainnet = parseInt(chainId, 16) === 1;\n\n      if (forceMainnet && !this.isMainnet) {\n        // Switch to mainnet\n        await this.switchToMainnet();\n      }\n\n      console.log(`Connected to ${this.isMainnet ? 'Mainnet' : 'Testnet'} (Chain ID: ${parseInt(chainId, 16)})`);\n      return true;\n\n    } catch (error) {\n      console.error('Failed to initialize real trading:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Switch to Ethereum mainnet\n   */\n  private async switchToMainnet(): Promise<void> {\n    try {\n      await window.ethereum.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: '0x1' }], // Ethereum mainnet\n      });\n      \n      // Wait for network switch\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      // Reinitialize provider after network switch\n      this.provider = window.ethereum;\n      this.signer = window.ethereum;\n      this.isMainnet = true;\n\n    } catch (error) {\n      console.error('Failed to switch to mainnet:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get token information from blockchain\n   */\n  async getTokenInfo(tokenAddress: string): Promise<TokenInfo | null> {\n    try {\n      if (!this.provider) throw new Error('Provider not initialized');\n\n      // For now, return mock data to avoid ethers dependency\n      // In production, would implement with native Web3 calls\n      const mockTokenInfo: TokenInfo = {\n        address: tokenAddress,\n        symbol: 'TOKEN',\n        name: 'Demo Token',\n        decimals: 18,\n        totalSupply: '1000000000000000000000000', // 1M tokens\n        liquidity_usd: Math.random() * 100000\n      };\n\n      return mockTokenInfo;\n\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get token liquidity from Uniswap\n   */\n  private async getTokenLiquidity(tokenAddress: string): Promise<number> {\n    try {\n      // This would call Uniswap subgraph or API\n      // For now, return a mock value\n      return Math.random() * 100000; // Random liquidity between 0-100k\n    } catch (error) {\n      console.error('Error getting token liquidity:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Execute real buy transaction\n   */\n  async buyToken(\n    tokenAddress: string,\n    amountETH: number,\n    config: TradingConfig\n  ): Promise<TradingResult> {\n    try {\n      if (!this.provider || !this.signer) {\n        throw new Error('Trading service not initialized');\n      }\n\n      if (!this.isMainnet) {\n        throw new Error('Real trading only available on mainnet');\n      }\n\n      // For now, simulate the transaction to avoid ethers dependency\n      // In production, would implement with native Web3 calls\n      console.log(`Simulating buy of ${amountETH} ETH worth of ${tokenAddress}`);\n      \n      // Simulate transaction hash\n      const mockTxHash = `0x${Math.random().toString(16).substring(2)}${Date.now().toString(16)}`;\n      \n      return {\n        success: true,\n        txHash: mockTxHash,\n        gasUsed: 21000,\n        actualPrice: amountETH * 1000, // Mock price\n        slippage: config.slippageTolerance * 0.5\n      };\n\n    } catch (error) {\n      console.error('Error executing buy transaction:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Transaction failed'\n      };\n    }\n  }\n\n  /**\n   * Execute real sell transaction\n   */\n  async sellToken(\n    tokenAddress: string,\n    tokenAmount: string,\n    config: TradingConfig\n  ): Promise<TradingResult> {\n    try {\n      if (!this.provider || !this.signer) {\n        throw new Error('Trading service not initialized');\n      }\n\n      // Similar to buyToken but for selling\n      // Would implement token approval and swap logic\n\n      return {\n        success: false,\n        error: 'Sell functionality not yet implemented'\n      };\n\n    } catch (error) {\n      console.error('Error executing sell transaction:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Transaction failed'\n      };\n    }\n  }\n\n  /**\n   * Get user's ETH balance\n   */\n  async getETHBalance(): Promise<number> {\n    try {\n      if (!this.provider) return 0;\n\n      const accounts = await this.provider.request({ method: 'eth_accounts' });\n      if (accounts.length === 0) return 0;\n\n      const balance = await this.provider.request({\n        method: 'eth_getBalance',\n        params: [accounts[0], 'latest']\n      });\n      \n      // Convert hex to decimal and then to ETH (divide by 10^18)\n      const balanceInWei = parseInt(balance, 16);\n      return balanceInWei / Math.pow(10, 18);\n    } catch (error) {\n      console.error('Error getting ETH balance:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get user's token balance\n   */\n  async getTokenBalance(tokenAddress: string): Promise<number> {\n    try {\n      if (!this.provider) return 0;\n\n      // For now, return mock balance to avoid ethers dependency\n      // In production, would implement with native Web3 contract calls\n      return Math.random() * 1000; // Random balance between 0-1000 tokens\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Check if connected to mainnet\n   */\n  isConnectedToMainnet(): boolean {\n    return this.isMainnet;\n  }\n\n  /**\n   * Get current network info\n   */\n  async getNetworkInfo(): Promise<{ chainId: number; name: string; isMainnet: boolean }> {\n    if (!this.provider) {\n      return { chainId: 0, name: 'Not connected', isMainnet: false };\n    }\n\n    try {\n      const chainId = await this.provider.request({ method: 'eth_chainId' });\n      const chainIdNum = parseInt(chainId, 16);\n      \n      const networkNames: Record<number, string> = {\n        1: 'Ethereum Mainnet',\n        5: 'Goerli Testnet',\n        11155111: 'Sepolia Testnet',\n        137: 'Polygon',\n        56: 'BSC'\n      };\n\n      return {\n        chainId: chainIdNum,\n        name: networkNames[chainIdNum] || `Chain ${chainIdNum}`,\n        isMainnet: chainIdNum === 1\n      };\n    } catch (error) {\n      console.error('Error getting network info:', error);\n      return { chainId: 0, name: 'Unknown', isMainnet: false };\n    }\n  }\n}\n\nexport const realTradingService = new RealTradingService();\nexport default realTradingService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}